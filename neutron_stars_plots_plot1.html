<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radius vs Rotational Period (color=age)</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            margin: 0;
            padding: 20px;
        }

        .plot-container {
            background: #2d2d2d;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin-top: 0;
            color: #4a9eff;
        }

        .loading {
            text-align: center;
            padding: 40px 20px;
            color: #888;
            font-size: 13px;
        }

        .spinner {
            display: inline-block;
            border: 3px solid #444;
            border-top: 3px solid #4a9eff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 0.8s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>
    <div class="plot-container">
        <h1>Radius vs Rotational Period (color=age)</h1>
        <div id="plot" style="width:100%;height:700px;"></div>
        <div class="loading" id="loading">
            <div class="spinner"></div>Loading data...
        </div>
    </div>

    <script>
        const plotConfig = { x: 'solarRadius', y: 'rotationalPeriod', color: 'age', title: 'Radius vs Rotational Period (color=age)', xlabel: 'Solar Radius (Râ˜‰)', ylabel: 'Rotational Period', colorbar: 'Age', colorscale: 'viridis' };
        const CSV_PATH = '../neutron_stars_plots_cache.csv';
        const INITIAL_CHUNK_SIZE = 100;
        const CHUNK_SIZE = 50000;

        let csvData = null;
        let csvHeaders = null;

        function parseCSVLine(line, headers) {
            const values = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    values.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            values.push(current.trim());

            const row = {};
            headers.forEach((h, i) => {
                const val = values[i];
                if (h && val !== undefined && val !== '') {
                    row[h] = isNaN(val) ? val : parseFloat(val);
                }
            });

            return row;
        }

        async function loadCSVStreaming() {
            if (csvData) return csvData;

            console.log('[CSV] Loading from ' + CSV_PATH);

            const response = await fetch(CSV_PATH);
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            let headersParsed = false;
            const allRows = [];
            let initialChunkResolved = false;
            let resolveInitial = null;
            const initialPromise = new Promise(r => { resolveInitial = r; });

            // Start streaming in background
            (async () => {
                try {
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) {
                            console.log('[CSV] Stream complete');
                            break;
                        }

                        buffer += decoder.decode(value, { stream: true });

                        const lines = buffer.split('\n');
                        buffer = lines[lines.length - 1];

                        for (let i = 0; i < lines.length - 1; i++) {
                            const line = lines[i].trim();
                            if (!line) continue;

                            if (!headersParsed) {
                                csvHeaders = line.split(',').map(h => h.trim().replace(/\r/g, ''));
                                headersParsed = true;
                                console.log('[CSV] Headers:', csvHeaders);
                            } else {
                                const row = parseCSVLine(line, csvHeaders);
                                allRows.push(row);

                                if (!initialChunkResolved && allRows.length >= INITIAL_CHUNK_SIZE) {
                                    csvData = [...allRows];
                                    console.log('[CSV] Initial chunk ready with ' + csvData.length + ' rows');
                                    resolveInitial(csvData);
                                    initialChunkResolved = true;
                                }

                                if (allRows.length % 100000 === 0) {
                                    console.log('[CSV] Received ' + allRows.length.toLocaleString() + ' rows');
                                }
                            }
                        }
                    }

                    if (buffer.trim() && headersParsed) {
                        const row = parseCSVLine(buffer.trim(), csvHeaders);
                        allRows.push(row);
                    }

                    csvData = allRows;
                    console.log('[CSV] Complete! Total rows: ' + csvData.length.toLocaleString());

                    if (!initialChunkResolved) {
                        resolveInitial(csvData);
                    }
                } catch (error) {
                    console.error('[CSV] Streaming error:', error);
                    if (!initialChunkResolved) {
                        resolveInitial(null);
                    }
                }
            })();

            return initialPromise;
        }

        async function loadAndStreamData() {
            const loadingDiv = document.getElementById('loading');
            const startTime = performance.now();

            console.log('[Plot] Starting load');

            try {
                const data = await loadCSVStreaming();
                if (!data) {
                    loadingDiv.innerHTML = '<div style="color: #f44336;">Error loading CSV</div>';
                    return;
                }

                const plotDiv = document.getElementById('plot');

                const processData = (rawData) => rawData.map(row => {
                    const radiusKm = row.solarRadius * 696000;
                    const periodSeconds = row.rotationalPeriod * 86400;
                    const tangVel = (2 * Math.PI * radiusKm) / periodSeconds;
                    return {
                        ...row,
                        tangentialVelocity: tangVel
                    };
                });

                const xField = plotConfig.x;
                const yField = plotConfig.y;
                const colorField = plotConfig.color;

                let processed = processData(data);

                const colorVals = processed.map(r => r[colorField]).filter(v => v !== null && v !== undefined && v > 0);
                let colorMin = Math.min(...colorVals);
                let colorMax = Math.max(...colorVals);

                const initialChunk = {};
                for (const key of Object.keys(processed[0])) {
                    initialChunk[key] = processed.slice(0, INITIAL_CHUNK_SIZE).map(r => r[key]);
                }

                const trace = {
                    x: initialChunk[xField],
                    y: initialChunk[yField],
                    mode: 'markers',
                    type: 'scattergl',
                    marker: {
                        size: 4,
                        color: initialChunk[colorField],
                        colorscale: plotConfig.colorscale === 'viridis' ? 'Viridis' : 'Plasma',
                        showscale: true,
                        colorbar: { title: plotConfig.colorbar },
                        cmin: colorMin,
                        cmax: colorMax
                    },
                    text: initialChunk.system,
                    hoverinfo: 'text'
                };

                const layout = {
                    title: plotConfig.title,
                    xaxis: { title: plotConfig.xlabel, type: 'log' },
                    yaxis: { title: plotConfig.ylabel, type: 'log' },
                    paper_bgcolor: '#1a1a1a',
                    plot_bgcolor: '#1a1a1a',
                    font: { color: '#fff' },
                    hovermode: 'closest',
                    autosize: false,
                    width: null,
                    height: 700,
                    margin: { l: 80, r: 80, t: 80, b: 80 }
                };

                Plotly.newPlot(plotDiv, [trace], layout, {
                    responsive: true,
                    displayModeBar: true
                });

                loadingDiv.innerHTML = '<div class="spinner"></div>Loading remaining ' + (data.length - INITIAL_CHUNK_SIZE).toLocaleString() + ' points...';

                (async () => {
                    try {
                        let offset = INITIAL_CHUNK_SIZE;
                        let updateCount = 0;

                        while (true) {
                            processed = processData(csvData);
                            const currentLength = processed.length;

                            while (offset < currentLength) {
                                const end = Math.min(offset + CHUNK_SIZE, currentLength);
                                const chunk = processed.slice(offset, end);

                                console.log('[Plot] Extending with chunk from ' + offset + ' to ' + end);

                                Plotly.extendTraces(plotDiv, {
                                    x: [chunk.map(r => r[xField])],
                                    y: [chunk.map(r => r[yField])],
                                    'marker.color': [chunk.map(r => r[colorField])],
                                    text: [chunk.map(r => r.system || '')]
                                }, [0]);

                                updateCount++;
                                offset = end;

                                if (offset % 50000 === 0 || offset >= currentLength) {
                                    loadingDiv.innerHTML = '<div class="spinner"></div>Loaded ' + offset.toLocaleString() + ' of ' + currentLength.toLocaleString() + '...';
                                    console.log('[Plot] Updated ' + updateCount + ' chunks, ' + offset + ' total rows');
                                }

                                await new Promise(resolve => setTimeout(resolve, 50));
                            }

                            await new Promise(resolve => setTimeout(resolve, 100));

                            processed = processData(csvData);
                            if (processed.length === offset) {
                                break;
                            }
                        }

                        loadingDiv.innerHTML = '';

                        const elapsed = ((performance.now() - startTime) / 1000).toFixed(1);
                        console.log('[Plot] Complete in ' + elapsed + 's with ' + updateCount + ' updates');
                    } catch (err) {
                        console.error('[Plot] Streaming error:', err);
                        loadingDiv.innerHTML = '<div style="color: #f44336;">Error streaming data: ' + err.message + '</div>';
                    }
                })();

            } catch (error) {
                console.error('[Plot] Error:', error);
                loadingDiv.innerHTML = '<div style="color: #f44336;">Error loading plot: ' + error.message + '</div>';
            }
        }

        window.addEventListener('DOMContentLoaded', () => {
            loadAndStreamData();
        });
    </script>
</body>

</html>
<div id="plot" style="width:100%;height:700px;"></div>
<div class="loading" id="loading">
    <div class="spinner"></div>Loading data...
</div>
</div>

<script id="configScript" type="application/json">
    {
        "csv_path": "./neutron_stars_plots_cache.csv",
        "initialChunkSize": 100,
        "chunkSize": 50000,
        "colorRanges": {"age": {"min": 282.0, "max": 13031.0}, "solarRadius": {"min": 1.0884705248023e-05, "max": 1.86803544543494e-05}, "rotationalPeriod": {"min": 2.44560185185185e-08, "max": 0.00042881217824067205}, "mass": {"min": 0.460938, "max": 2.382813}, "temperature": {"min": 991309.9, "max": 9908563.2}},
        "plot": {"x": "solarRadius", "y": "rotationalPeriod", "color": "age", "title": "Radius vs Rotational Period (color=age)", "xlabel": "Solar Radius (R\u2609)", "ylabel": "Rotational Period", "colorbar": "Age", "colorscale": "viridis"}
    }
    </script>

<script>
    const config = JSON.parse(document.getElementById('configScript').textContent);
    let csvData = null;
    let csvHeaders = null;

    function parseCSVLine(line, headers) {
        const values = [];
        let current = '';
        let inQuotes = false;

        for (let i = 0; i < line.length; i++) {
            const char = line[i];
            if (char === '"') {
                inQuotes = !inQuotes;
            } else if (char === ',' && !inQuotes) {
                values.push(current.trim());
                current = '';
            } else {
                current += char;
            }
        }
        values.push(current.trim());

        const row = {};
        headers.forEach((h, i) => {
            const val = values[i];
            if (h && val !== undefined && val !== '') {
                row[h] = isNaN(val) ? val : parseFloat(val);
            }
        });

        return row;
    }

    async function loadCSVStreaming() {
        if (csvData) return csvData;

        console.log('[CSV] Loading from ' + config.csv_path);

        const response = await fetch(config.csv_path);
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        let headersParsed = false;
        const allRows = [];
        let initialChunkResolved = false;
        let resolveInitial = null;
        const initialPromise = new Promise(r => { resolveInitial = r; });

        // Start streaming in background without awaiting
        (async () => {
            try {
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) {
                        console.log('[CSV] Stream complete');
                        break;
                    }

                    buffer += decoder.decode(value, { stream: true });

                    // Try to parse complete lines from buffer
                    const lines = buffer.split('\n');

                    // Keep the last incomplete line in buffer
                    buffer = lines[lines.length - 1];

                    // Process all complete lines
                    for (let i = 0; i < lines.length - 1; i++) {
                        const line = lines[i].trim();
                        if (!line) continue;

                        if (!headersParsed) {
                            csvHeaders = line.split(',').map(h => h.trim().replace(/\r/g, ''));
                            headersParsed = true;
                            console.log('[CSV] Headers:', csvHeaders);
                        } else {
                            const row = parseCSVLine(line, csvHeaders);
                            allRows.push(row);

                            // Resolve initial promise as soon as we have enough rows
                            if (!initialChunkResolved && allRows.length >= config.initialChunkSize) {
                                csvData = [...allRows];
                                console.log('[CSV] Initial chunk ready with ' + csvData.length + ' rows');
                                resolveInitial(csvData);
                                initialChunkResolved = true;
                            }

                            if (allRows.length % 100000 === 0) {
                                console.log('[CSV] Received ' + allRows.length.toLocaleString() + ' rows');
                            }
                        }
                    }
                }

                // Handle any remaining data in buffer
                if (buffer.trim() && headersParsed) {
                    const row = parseCSVLine(buffer.trim(), csvHeaders);
                    allRows.push(row);
                }

                csvData = allRows;
                console.log('[CSV] Complete! Total rows: ' + csvData.length.toLocaleString());

                if (!initialChunkResolved) {
                    resolveInitial(csvData);
                }
            } catch (error) {
                console.error('[CSV] Streaming error:', error);
                if (!initialChunkResolved) {
                    resolveInitial(null);
                }
            }
        })();

        return initialPromise;
    }

    async function loadCSV() {
        return await loadCSVStreaming();
    }

    async function loadAndStreamData() {
        const loadingDiv = document.getElementById('loading');
        const plotConfig = config.plot;
        const startTime = performance.now();

        console.log('[Plot] Starting load for: ' + plotConfig.title);

        try {
            const data = await loadCSV();
            const plotDiv = document.getElementById('plot');

            // Function to process raw data with derived fields
            const processData = (rawData) => rawData.map(row => {
                const radiusKm = row.solarRadius * 696000;
                const periodSeconds = row.rotationalPeriod * 86400;
                const tangVel = (2 * Math.PI * radiusKm) / periodSeconds;
                return {
                    ...row,
                    tangentialVelocity: tangVel
                };
            });

            // Get field for x and y axes
            const xField = plotConfig.x;
            const yField = plotConfig.y;
            const colorField = plotConfig.color;

            let processed = processData(data);

            // Extract values
            const xVals = processed.map(r => r[xField]).filter(v => v !== null && v !== undefined && v > 0);
            const yVals = processed.map(r => r[yField]).filter(v => v !== null && v !== undefined && v > 0);
            const colorVals = processed.map(r => r[colorField]).filter(v => v !== null && v !== undefined && v > 0);

            // Use pre-calculated color ranges if available
            let colorMin, colorMax;
            if (config.colorRanges[colorField]) {
                colorMin = config.colorRanges[colorField].min;
                colorMax = config.colorRanges[colorField].max;
            } else {
                colorMin = Math.min(...colorVals);
                colorMax = Math.max(...colorVals);
            }

            // Create initial trace with first N points
            const initialChunk = {};
            for (const key of Object.keys(processed[0])) {
                initialChunk[key] = processed.slice(0, config.initialChunkSize).map(r => r[key]);
            }

            const trace = {
                x: initialChunk[xField],
                y: initialChunk[yField],
                mode: 'markers',
                type: 'scattergl',
                marker: {
                    size: 4,
                    color: initialChunk[colorField],
                    colorscale: plotConfig.colorscale === 'viridis' ? 'Viridis' : 'Plasma',
                    showscale: true,
                    colorbar: { title: plotConfig.colorbar },
                    cmin: colorMin,
                    cmax: colorMax
                },
                text: initialChunk.system,
                hoverinfo: 'text'
            };

            const layout = {
                title: plotConfig.title,
                xaxis: { title: plotConfig.xlabel, type: 'log' },
                yaxis: { title: plotConfig.ylabel, type: 'log' },
                paper_bgcolor: '#1a1a1a',
                plot_bgcolor: '#1a1a1a',
                font: { color: '#fff' },
                hovermode: 'closest',
                autosize: false,
                width: null,
                height: 700,
                margin: { l: 80, r: 80, t: 80, b: 80 }
            };

            if (plotConfig.reference_line) {
                layout.shapes = [{
                    type: 'line',
                    x0: Math.min(...trace.x),
                    x1: Math.max(...trace.x),
                    y0: plotConfig.reference_line,
                    y1: plotConfig.reference_line,
                    line: { color: '#00ff00', width: 2, dash: 'dash' }
                }];
            }

            Plotly.newPlot(plotDiv, [trace], layout, {
                responsive: true,
                displayModeBar: true
            });

            loadingDiv.innerHTML = '<div class="spinner"></div>Loading remaining ' + (data.length - config.initialChunkSize).toLocaleString() + ' points...';

            // Stream remaining data in background with delays to allow rendering
            (async () => {
                try {
                    let offset = config.initialChunkSize;
                    let updateCount = 0;

                    // Keep checking for new data until CSV loading completes
                    while (true) {
                        // Recalculate processed data from current csvData each iteration
                        processed = processData(csvData);
                        const currentLength = processed.length;

                        // Process any new data available
                        while (offset < currentLength) {
                            const end = Math.min(offset + config.chunkSize, currentLength);
                            const chunk = processed.slice(offset, end);

                            console.log('[Plot] Extending with chunk from ' + offset + ' to ' + end);

                            Plotly.extendTraces(plotDiv, {
                                x: [[chunk.map(r => r[xField])]],
                                y: [[chunk.map(r => r[yField])]],
                                'marker.color': [[chunk.map(r => r[colorField])]],
                                text: [[chunk.map(r => r.system || '')]]
                            }, [0]);

                            updateCount++;
                            offset = end;

                            if (offset % 50000 === 0 || offset >= currentLength) {
                                loadingDiv.innerHTML = '<div class="spinner"></div>Loaded ' + offset.toLocaleString() + ' of ' + currentLength.toLocaleString() + '...';
                                console.log('[Plot] Updated ' + updateCount + ' chunks, ' + offset + ' total rows');
                            }

                            // Yield to browser to allow rendering
                            await new Promise(resolve => setTimeout(resolve, 50));
                        }

                        // Check if we've caught up to current data length
                        // Wait a bit to see if more data arrives from CSV stream
                        await new Promise(resolve => setTimeout(resolve, 100));

                        // Recheck if new data has arrived
                        processed = processData(csvData);
                        if (processed.length === offset) {
                            // No new data arrived, we're done
                            break;
                        }
                    }

                    loadingDiv.innerHTML = '';

                    const elapsed = ((performance.now() - startTime) / 1000).toFixed(1);
                    console.log('[Plot] Complete in ' + elapsed + 's with ' + updateCount + ' updates');
                } catch (err) {
                    console.error('[Plot] Streaming error:', err);
                    loadingDiv.innerHTML = '<div style="color: #f44336;">Error streaming data: ' + err.message + '</div>';
                }
            })();

        } catch (error) {
            console.error('[Plot] Error:', error);
            loadingDiv.innerHTML = '<div style="color: #f44336;">Error loading plot: ' + error.message + '</div>';
        }
    }

    window.addEventListener('DOMContentLoaded', () => {
        loadAndStreamData();
    });

    // Handle window resize to prevent plot from vanishing
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            const plotDiv = document.getElementById('plot');
            if (plotDiv && plotDiv.data && plotDiv.layout) {
                const container = plotDiv.parentElement;
                const width = container.offsetWidth;
                Plotly.relayout(plotDiv, {
                    width: width,
                    height: 700
                });
            }
        }, 100);
    });
</script>
</body>

</html>