<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neutron Stars Analysis</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
        }

        .header {
            background: #2d2d2d;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        h1 {
            font-size: 24px;
            font-weight: 600;
        }

        .subtitle {
            color: #888;
            font-size: 14px;
            margin-top: 5px;
        }

        .tabs {
            display: flex;
            background: #2d2d2d;
            padding: 0 20px;
            border-bottom: 1px solid #444;
            overflow-x: auto;
        }

        .tab {
            padding: 15px 25px;
            cursor: pointer;
            border: none;
            background: none;
            color: #888;
            font-size: 14px;
            font-weight: 500;
            white-space: nowrap;
            transition: all 0.2s;
            border-bottom: 3px solid transparent;
        }

        .tab:hover {
            color: #fff;
            background: rgba(255, 255, 255, 0.05);
        }

        .tab.active {
            color: #4a9eff;
            border-bottom-color: #4a9eff;
        }

        .tab-content {
            display: none;
            padding: 20px;
            animation: fadeIn 0.3s;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .plot-container {
            background: #2d2d2d;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            overflow-x: auto;
        }

        .loading {
            text-align: center;
            padding: 40px 20px;
            color: #888;
            font-size: 13px;
        }

        .spinner {
            display: inline-block;
            border: 3px solid #444;
            border-top: 3px solid #4a9eff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 0.8s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .help {
            background: #2d2d2d;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 8px;
            font-size: 13px;
            color: #aaa;
        }

        .help strong {
            color: #4a9eff;
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>Neutron Stars Analysis</h1>
        <div class="subtitle">Interactive controls: zoom, pan, box select | Data loads on-demand with streaming</div>
    </div>

    <div class="tabs">
        <button class="tab active" onclick="showTab(0)">Radius vs Rotational Period</button>
        <button class="tab" onclick="showTab(1)">Rotational Period vs Age</button>
        <button class="tab" onclick="showTab(2)">Radius vs Age</button>
        <button class="tab" onclick="showTab(3)">Tangential Velocity vs Age</button>
        <button class="tab" onclick="showTab(4)">Temperature vs Age</button>
        <button class="tab" onclick="showTab(5)">Mass vs Radius</button>
        <button class="tab" onclick="showTab(6)">P-Ṗ Diagram</button>
        <button class="tab" onclick="showTab(7)">Rotational Period vs Mass</button>
        <button class="tab" onclick="showTab(8)">Mass vs Age</button>
        <button class="tab" onclick="showTab(9)">Tangential Velocity vs Mass</button>
        <button class="tab" onclick="showTab(10)">Histograms</button>
    </div>

    <div id="tab0" class="tab-content active">
        <div class="help"><strong>Controls:</strong> Zoom, pan, hover for details. This plot streams data as it loads.
        </div>
        <div class="plot-container">
            <div id="plot-0" style="width:100%;height:700px;"></div>
            <div class="loading" id="loading-0"></div>
        </div>
    </div>

    <div id="tab1" class="tab-content">
        <div class="help"><strong>Controls:</strong> Zoom, pan, hover for details. This plot streams data as it loads.
        </div>
        <div class="plot-container">
            <div id="plot-1" style="width:100%;height:700px;"></div>
            <div class="loading" id="loading-1"></div>
        </div>
    </div>

    <div id="tab2" class="tab-content">
        <div class="help"><strong>Controls:</strong> Zoom, pan, hover for details. This plot streams data as it loads.
        </div>
        <div class="plot-container">
            <div id="plot-2" style="width:100%;height:700px;"></div>
            <div class="loading" id="loading-2"></div>
        </div>
    </div>

    <div id="tab3" class="tab-content">
        <div class="help"><strong>Controls:</strong> Zoom, pan, hover for details. This plot streams data as it loads.
        </div>
        <div class="plot-container">
            <div id="plot-3" style="width:100%;height:700px;"></div>
            <div class="loading" id="loading-3"></div>
        </div>
    </div>

    <div id="tab4" class="tab-content">
        <div class="help"><strong>Controls:</strong> Zoom, pan, hover for details. This plot streams data as it loads.
        </div>
        <div class="plot-container">
            <div id="plot-4" style="width:100%;height:700px;"></div>
            <div class="loading" id="loading-4"></div>
        </div>
    </div>

    <div id="tab5" class="tab-content">
        <div class="help"><strong>Controls:</strong> Zoom, pan, hover for details. This plot streams data as it loads.
        </div>
        <div class="plot-container">
            <div id="plot-5" style="width:100%;height:700px;"></div>
            <div class="loading" id="loading-5"></div>
        </div>
    </div>

    <div id="tab6" class="tab-content">
        <div class="help"><strong>P-Ṗ Diagram:</strong> Classic pulsar diagram showing period vs period derivative. Red
            dashed line = death line (pulsars below cannot emit radio waves). Dotted lines = constant age contours.
        </div>
        <div class="plot-container">
            <div id="plot-6" style="width:100%;height:700px;"></div>
            <div class="loading" id="loading-6"></div>
        </div>
    </div>

    <div id="tab7" class="tab-content">
        <div class="help"><strong>Controls:</strong> Zoom, pan, hover for details. This plot streams data as it loads.
        </div>
        <div class="plot-container">
            <div id="plot-7" style="width:100%;height:700px;"></div>
            <div class="loading" id="loading-7"></div>
        </div>
    </div>

    <div id="tab8" class="tab-content">
        <div class="help"><strong>Controls:</strong> Zoom, pan, hover for details. This plot streams data as it loads.
        </div>
        <div class="plot-container">
            <div id="plot-8" style="width:100%;height:700px;"></div>
            <div class="loading" id="loading-8"></div>
        </div>
    </div>

    <div id="tab9" class="tab-content">
        <div class="help"><strong>Controls:</strong> Zoom, pan, hover for details. This plot streams data as it loads.
        </div>
        <div class="plot-container">
            <div id="plot-9" style="width:100%;height:700px;"></div>
            <div class="loading" id="loading-9"></div>
        </div>
    </div>

    <div id="tab10" class="tab-content">
        <div class="help"><strong>Distributions:</strong> Histograms showing the distribution of various neutron star parameters.
        </div>
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px;">
            <div class="plot-container">
                <div id="hist-radius" style="width:100%;height:400px;"></div>
            </div>
            <div class="plot-container">
                <div id="hist-period" style="width:100%;height:400px;"></div>
            </div>
            <div class="plot-container">
                <div id="hist-age" style="width:100%;height:400px;"></div>
            </div>
            <div class="plot-container">
                <div id="hist-mass" style="width:100%;height:400px;"></div>
            </div>
            <div class="plot-container">
                <div id="hist-temperature" style="width:100%;height:400px;"></div>
            </div>
            <div class="plot-container">
                <div id="hist-velocity" style="width:100%;height:400px;"></div>
            </div>
            <div class="plot-container">
                <div id="hist-spin" style="width:100%;height:400px;"></div>
            </div>
        </div>
        <div class="loading" id="loading-10"></div>
    </div>

    <script>
        const CSV_PATH = 'neutron_stars_plots_cache.csv.gz';
        const INITIAL_CHUNK_SIZE = 50000;
        const CHUNK_SIZE = 100000;
        const BATCH_INTERVAL = 500; // Update every 500ms for more visible progress
        const UPDATE_BATCH_SIZE = 50000; // Optimized: Larger batches = fewer updates

        let dataWorker = null;

        const plots = [
            { x: 'solarRadius', y: 'rotationalPeriod', color: 'age', title: 'Radius vs Rotational Period (color=age)', xlabel: 'Solar Radius (R☉)', ylabel: 'Rotational Period', colorbar: 'Age', colorscale: 'viridis' },
            { x: 'age', y: 'rotationalPeriod', color: 'solarRadius', title: 'Rotational Period vs Age (color=radius)', xlabel: 'Age', ylabel: 'Rotational Period', colorbar: 'Radius (R☉)', colorscale: 'plasma' },
            { x: 'age', y: 'solarRadius', color: 'rotationalPeriod', title: 'Radius vs Age (color=rotational period)', xlabel: 'Age', ylabel: 'Solar Radius (R☉)', colorbar: 'Rotational Period', colorscale: 'viridis' },
            { x: 'age', y: 'tangentialVelocity', color: 'mass', title: 'Tangential Velocity vs Age (color=mass)', xlabel: 'Age', ylabel: 'Tangential Velocity (km/s)', colorbar: 'Mass (M☉)', colorscale: 'plasma', reference_line: 299792 },
            { x: 'age', y: 'temperature', color: 'solarRadius', title: 'Temperature vs Age (color=radius)', xlabel: 'Age', ylabel: 'Temperature (K)', colorbar: 'Radius (R☉)', colorscale: 'plasma' },
            { x: 'mass', y: 'solarRadius', color: 'rotationalPeriod', title: 'Radius vs Mass (color=rotational period)', xlabel: 'Mass (M☉)', ylabel: 'Radius (R☉)', colorbar: 'Rotational Period', colorscale: 'viridis' },
            { x: 'rotationalPeriod', y: 'periodDerivative', color: 'age', title: 'P-Ṗ Diagram (color=age)', xlabel: 'Period P (days)', ylabel: 'Period Derivative Ṗ (s/s)', colorbar: 'Age (Myr)', colorscale: 'viridis', ppdot: true },
            { x: 'mass', y: 'rotationalPeriod', color: 'age', title: 'Rotational Period vs Mass (color=age)', xlabel: 'Mass (M☉)', ylabel: 'Rotational Period (days)', colorbar: 'Age (Myr)', colorscale: 'viridis' },
            { x: 'age', y: 'mass', color: 'temperature', title: 'Mass vs Age (color=temperature)', xlabel: 'Age (Myr)', ylabel: 'Mass (M☉)', colorbar: 'Temperature (K)', colorscale: 'viridis' },
            { x: 'mass', y: 'tangentialVelocity', color: 'age', title: 'Tangential Velocity vs Mass (color=age)', xlabel: 'Mass (M☉)', ylabel: 'Tangential Velocity (km/s)', colorbar: 'Age (Myr)', colorscale: 'viridis', reference_line: 299792 }
        ];

        let csvData = [];
        let csvHeaders = null;
        let csvComplete = false;
        let loadedTabs = new Set();
        let workerMessageId = 0;
        let workerCallbacks = new Map();

        // Format hover text with proper units
        function formatHoverText(row) {
            const SPEED_OF_LIGHT = 299792; // km/s
            const radiusKm = row.solarRadius * 696000;

            let hoverParts = [`<b>${row.system}</b>`];

            // Radius: show both km and solar radius
            if (row.solarRadius !== undefined) {
                hoverParts.push(`Radius: ${radiusKm.toLocaleString(undefined, { maximumFractionDigits: 0 })} km (${row.solarRadius.toFixed(3)} R☉)`);
            }

            // Rotational Period: show in km/s or c
            if (row.rotationalPeriod !== undefined && row.tangentialVelocity !== undefined) {
                if (row.tangentialVelocity >= 0.1 * SPEED_OF_LIGHT) {
                    const speedInC = row.tangentialVelocity / SPEED_OF_LIGHT;
                    hoverParts.push(`Rotational Velocity: ${speedInC.toFixed(3)}c`);
                } else {
                    hoverParts.push(`Rotational Velocity: ${row.tangentialVelocity.toLocaleString(undefined, { maximumFractionDigits: 1 })} km/s`);
                }

                // Format rotational period with appropriate unit
                const periodDays = row.rotationalPeriod;
                const periodSeconds = periodDays * 86400;

                if (periodSeconds < 1) {
                    // Less than 1 second - show in milliseconds
                    hoverParts.push(`Rotational Period: ${(periodSeconds * 1000).toFixed(2)} ms`);
                } else if (periodSeconds < 60) {
                    // Less than 1 minute - show in seconds
                    hoverParts.push(`Rotational Period: ${periodSeconds.toFixed(3)} s`);
                } else if (periodSeconds < 3600) {
                    // Less than 1 hour - show in minutes
                    hoverParts.push(`Rotational Period: ${(periodSeconds / 60).toFixed(2)} min`);
                } else if (periodDays < 1) {
                    // Less than 1 day - show in hours
                    hoverParts.push(`Rotational Period: ${(periodSeconds / 3600).toFixed(2)} hr`);
                } else if (periodDays < 365.25) {
                    // Less than 1 year - show in days
                    hoverParts.push(`Rotational Period: ${periodDays.toFixed(2)} days`);
                } else if (periodDays < 36525) {
                    // Less than 100 years - show in years
                    const periodYears = periodDays / 365.25;
                    hoverParts.push(`Rotational Period: ${periodYears.toFixed(2)} years`);
                } else {
                    // 100 years or more - show in centuries
                    const periodCenturies = periodDays / 36525;
                    hoverParts.push(`Rotational Period: ${periodCenturies.toFixed(2)} centuries`);
                }
            }

            // Age in millions of years (already stored as Myr in CSV)
            if (row.age !== undefined) {
                const ageMyr = row.age;
                if (ageMyr >= 1000) {
                    // Show in billions of years for large values
                    const ageGyr = ageMyr / 1000;
                    hoverParts.push(`Age: ${ageGyr.toLocaleString(undefined, { maximumFractionDigits: 2 })} Gyr`);
                } else {
                    hoverParts.push(`Age: ${ageMyr.toLocaleString(undefined, { maximumFractionDigits: 1 })} Myr`);
                }
            }

            // Temperature in Kelvin
            if (row.temperature !== undefined) {
                hoverParts.push(`Temperature: ${row.temperature.toLocaleString(undefined, { maximumFractionDigits: 0 })} K`);
            }

            // Mass in solar masses
            if (row.mass !== undefined) {
                hoverParts.push(`Mass: ${row.mass.toFixed(3)} M☉`);
            }

            // Spin state
            if (row.spin !== undefined) {
                hoverParts.push(`Spin: ${row.spin}`);
            }

            return hoverParts.join('<br>');
        }

        // Web Worker for data processing
        function createDataWorker() {
            const workerCode = `
                // Format hover text with proper units (inside worker for speed)
                function formatHoverText(row) {
                    const SPEED_OF_LIGHT = 299792; // km/s
                    const radiusKm = row.solarRadius * 696000;
                    
                    let hoverParts = ['<b>' + row.system + '</b>'];
                    
                    // Radius: show both km and solar radius
                    if (row.solarRadius !== undefined) {
                        hoverParts.push('Radius: ' + radiusKm.toFixed(0) + ' km (' + row.solarRadius.toFixed(3) + ' R☉)');
                    }
                    
                    // Rotational Period: show in km/s or c
                    if (row.rotationalPeriod !== undefined && row.tangentialVelocity !== undefined) {
                        if (row.tangentialVelocity >= 0.1 * SPEED_OF_LIGHT) {
                            const speedInC = row.tangentialVelocity / SPEED_OF_LIGHT;
                            hoverParts.push('Rotational Velocity: ' + speedInC.toFixed(3) + 'c');
                        } else {
                            hoverParts.push('Rotational Velocity: ' + row.tangentialVelocity.toFixed(1) + ' km/s');
                        }
                        
                        // Format rotational period with appropriate unit
                        const periodDays = row.rotationalPeriod;
                        const periodSeconds = periodDays * 86400;
                        
                        if (periodSeconds < 1) {
                            hoverParts.push('Rotational Period: ' + (periodSeconds * 1000).toFixed(2) + ' ms');
                        } else if (periodSeconds < 60) {
                            hoverParts.push('Rotational Period: ' + periodSeconds.toFixed(3) + ' s');
                        } else if (periodSeconds < 3600) {
                            hoverParts.push('Rotational Period: ' + (periodSeconds / 60).toFixed(2) + ' min');
                        } else if (periodDays < 1) {
                            hoverParts.push('Rotational Period: ' + (periodSeconds / 3600).toFixed(2) + ' hr');
                        } else if (periodDays < 365.25) {
                            hoverParts.push('Rotational Period: ' + periodDays.toFixed(2) + ' days');
                        } else if (periodDays < 36525) {
                            const periodYears = periodDays / 365.25;
                            hoverParts.push('Rotational Period: ' + periodYears.toFixed(2) + ' years');
                        } else {
                            const periodCenturies = periodDays / 36525;
                            hoverParts.push('Rotational Period: ' + periodCenturies.toFixed(2) + ' centuries');
                        }
                    }
                    
                    // Age in millions of years
                    if (row.age !== undefined) {
                        const ageMyr = row.age;
                        if (ageMyr >= 1000) {
                            const ageGyr = ageMyr / 1000;
                            hoverParts.push('Age: ' + ageGyr.toFixed(2) + ' Gyr');
                        } else {
                            hoverParts.push('Age: ' + ageMyr.toFixed(1) + ' Myr');
                        }
                    }
                    
                    // Temperature in Kelvin
                    if (row.temperature !== undefined) {
                        hoverParts.push('Temperature: ' + row.temperature.toFixed(0) + ' K');
                    }
                    
                    // Mass in solar masses
                    if (row.mass !== undefined) {
                        hoverParts.push('Mass: ' + row.mass.toFixed(3) + ' M☉');
                    }
                    
                    // Spin state
                    if (row.spin !== undefined) {
                        hoverParts.push('Spin: ' + row.spin);
                    }
                    
                    return hoverParts.join('<br>');
                }
            
                self.onmessage = function(e) {
                    const { type, data, fields, id } = e.data;
                    
                    if (type === 'process') {
                        const processed = data.map(row => {
                            const radiusKm = row.solarRadius * 696000;
                            const periodSeconds = row.rotationalPeriod * 86400;
                            const tangVel = (2 * Math.PI * radiusKm) / periodSeconds;
                            
                            // Calculate period derivative: P-dot = P / (2 * tau)
                            // age is in Myr, convert to seconds: age * 1e6 * 365.25 * 86400
                            const ageSeconds = row.age * 1e6 * 365.25 * 86400;
                            const periodDerivative = periodSeconds / (2 * ageSeconds);
                            
                            const processedRow = {
                                ...row,
                                tangentialVelocity: tangVel,
                                periodDerivative: periodDerivative
                            };
                            // Pre-compute hover text in worker
                            processedRow.hoverText = formatHoverText(processedRow);
                            return processedRow;
                        });
                        
                        // Return full processed rows with pre-computed hover text
                        self.postMessage({ type: 'processed', data: processed, id: id });
                    }
                };
            `;

            const blob = new Blob([workerCode], { type: 'application/javascript' });
            const worker = new Worker(URL.createObjectURL(blob));

            // Set up single message handler that routes to callbacks
            worker.onmessage = (e) => {
                const { id, type, data } = e.data;
                if (type === 'processed' && workerCallbacks.has(id)) {
                    workerCallbacks.get(id)(data);
                    workerCallbacks.delete(id);
                }
            };

            return worker;
        }

        // Helper to process data with worker
        function processWithWorker(data, fields) {
            return new Promise((resolve) => {
                const id = workerMessageId++;
                workerCallbacks.set(id, resolve);
                dataWorker.postMessage({
                    type: 'process',
                    data: data,
                    fields: fields,
                    id: id
                });
            });
        }

        // Smart downsampling: reduce overlapping points at default zoom
        function downsampleForDisplay(rows, xField, yField, colorField, gridSize = 800) {
            if (rows.length === 0) return rows;

            // Find data ranges (in log space since we use log axes)
            let xMin = Infinity, xMax = -Infinity;
            let yMin = Infinity, yMax = -Infinity;
            let validCount = 0;

            for (const row of rows) {
                const x = row[xField];
                const y = row[yField];
                if (x > 0 && y > 0 && isFinite(x) && isFinite(y)) {
                    const logX = Math.log10(x);
                    const logY = Math.log10(y);
                    if (isFinite(logX) && isFinite(logY)) {
                        if (logX < xMin) xMin = logX;
                        if (logX > xMax) xMax = logX;
                        if (logY < yMin) yMin = logY;
                        if (logY > yMax) yMax = logY;
                        validCount++;
                    }
                }
            }

            // If no valid points or ranges are invalid, return original
            if (validCount === 0 || !isFinite(xMin) || !isFinite(xMax) || !isFinite(yMin) || !isFinite(yMax)) {
                console.log('[Downsample] No valid points for downsampling, returning original');
                return rows;
            }

            // Create spatial grid
            const grid = new Map();
            const xRange = xMax - xMin;
            const yRange = yMax - yMin;

            // Safety check for range
            if (xRange === 0 || yRange === 0) {
                console.log('[Downsample] Zero range detected, returning original');
                return rows;
            }

            // Bin points into grid cells (store arrays of points per cell)
            for (const row of rows) {
                const x = row[xField];
                const y = row[yField];
                if (x > 0 && y > 0 && isFinite(x) && isFinite(y)) {
                    const logX = Math.log10(x);
                    const logY = Math.log10(y);

                    if (isFinite(logX) && isFinite(logY)) {
                        // Calculate grid cell
                        const cellX = Math.floor((logX - xMin) / xRange * gridSize);
                        const cellY = Math.floor((logY - yMin) / yRange * gridSize);
                        const cellKey = cellX + ',' + cellY;

                        // Store all points in this cell
                        if (!grid.has(cellKey)) {
                            grid.set(cellKey, []);
                        }
                        grid.get(cellKey).push(row);
                    }
                }
            }

            // Select representative points from each cell
            // Keep 1 point per cell, or more if there's significant color variation
            const sampled = [];

            for (const cellPoints of grid.values()) {
                if (cellPoints.length === 1) {
                    sampled.push(cellPoints[0]);
                    continue;
                }

                // For cells with multiple points, check color variation
                const pointsWithColor = cellPoints.filter(p => p[colorField] !== undefined && isFinite(p[colorField]));

                if (pointsWithColor.length === 0) {
                    sampled.push(cellPoints[0]);
                    continue;
                }

                // Sort by color value
                pointsWithColor.sort((a, b) => a[colorField] - b[colorField]);

                const minColor = pointsWithColor[0][colorField];
                const maxColor = pointsWithColor[pointsWithColor.length - 1][colorField];
                const colorRange = maxColor - minColor;
                const avgColor = (minColor + maxColor) / 2;

                // If color variation is significant (>20% of average), keep min/mid/max
                // Otherwise just keep one representative
                if (colorRange > avgColor * 0.2 && pointsWithColor.length >= 3) {
                    // Keep 3 points showing color range
                    sampled.push(pointsWithColor[0]); // min
                    sampled.push(pointsWithColor[Math.floor(pointsWithColor.length / 2)]); // mid
                    sampled.push(pointsWithColor[pointsWithColor.length - 1]); // max
                } else {
                    // Keep just one point (median)
                    sampled.push(pointsWithColor[Math.floor(pointsWithColor.length / 2)]);
                }
            }

            // Safety check: if downsampling removed too many points, return original
            if (sampled.length === 0) {
                console.log('[Downsample] Result was empty, returning original');
                return rows;
            }

            console.log('[Downsample] Reduced ' + rows.length.toLocaleString() + ' → ' + sampled.length.toLocaleString() + ' points (' + (sampled.length / rows.length * 100).toFixed(1) + '%)');
            return sampled;
        }

        function parseCSVLine(line, headers) {
            const values = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    values.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            values.push(current.trim());

            const row = {};
            headers.forEach((h, i) => {
                const val = values[i];
                if (h && val !== undefined && val !== '') {
                    row[h] = isNaN(val) ? val : parseFloat(val);
                }
            });

            return row;
        }

        async function loadCSVStreaming() {
            if (csvData.length > 0) return csvData;

            console.log('[CSV] Loading from ' + CSV_PATH);

            const response = await fetch(CSV_PATH);
            const reader = response.body.pipeThrough(new DecompressionStream('gzip')).getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            let headersParsed = false;
            let initialChunkResolved = false;
            let resolveInitial = null;
            const initialPromise = new Promise(r => { resolveInitial = r; });

            // Start streaming in background
            (async () => {
                try {
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) {
                            console.log('[CSV] Stream complete');
                            csvComplete = true;
                            break;
                        }

                        buffer += decoder.decode(value, { stream: true });

                        const lines = buffer.split('\n');
                        buffer = lines[lines.length - 1];

                        for (let i = 0; i < lines.length - 1; i++) {
                            const line = lines[i].trim();
                            if (!line) continue;

                            if (!headersParsed) {
                                csvHeaders = line.split(',').map(h => h.trim().replace(/\r/g, ''));
                                headersParsed = true;
                                console.log('[CSV] Headers:', csvHeaders);
                            } else {
                                const row = parseCSVLine(line, csvHeaders);
                                csvData.push(row);

                                if (!initialChunkResolved && csvData.length >= INITIAL_CHUNK_SIZE) {
                                    console.log('[CSV] Initial chunk ready with ' + csvData.length + ' rows');
                                    resolveInitial(csvData);
                                    initialChunkResolved = true;
                                }

                                if (csvData.length % 100000 === 0) {
                                    console.log('[CSV] Received ' + csvData.length.toLocaleString() + ' rows');
                                }
                            }
                        }
                    }

                    if (buffer.trim() && headersParsed) {
                        const row = parseCSVLine(buffer.trim(), csvHeaders);
                        csvData.push(row);
                    }

                    console.log('[CSV] Complete! Total rows: ' + csvData.length.toLocaleString());

                    if (!initialChunkResolved) {
                        resolveInitial(csvData);
                    }
                } catch (error) {
                    console.error('[CSV] Streaming error:', error);
                    if (!initialChunkResolved) {
                        resolveInitial(null);
                    }
                }
            })();

            return initialPromise;
        }

        function showTab(index) {
            const tabs = document.querySelectorAll('.tab');
            const contents = document.querySelectorAll('.tab-content');

            tabs.forEach((tab, i) => {
                tab.classList.toggle('active', i === index);
            });

            contents.forEach((content, i) => {
                content.classList.toggle('active', i === index);
            });

            if (!loadedTabs.has(index)) {
                console.log('[Tab ' + index + '] Loading plot...');
                if (index === 10) {
                    loadHistograms(index);
                } else {
                    loadAndStreamData(index);
                }
            } else {
                console.log('[Tab ' + index + '] Already loaded');
                // Ensure loading div shows completion status, not spinner
                const loadingDiv = document.getElementById('loading-' + index);
                if (loadingDiv && loadingDiv.innerHTML.includes('spinner')) {
                    const totalPoints = csvData.length;
                    loadingDiv.innerHTML = '<div style="color: #4a9eff; font-weight: 500;">✓ Loaded ' + totalPoints.toLocaleString() + ' data points</div>';
                }
            }
        }

        async function loadHistograms(tabIndex) {
            const loadingDiv = document.getElementById('loading-' + tabIndex);
            loadingDiv.innerHTML = '<div class="spinner"></div>Waiting for complete dataset...';

            // Wait a moment for tab to fully render
            await new Promise(resolve => setTimeout(resolve, 100));

            try {
                // Get initial data
                const data = await loadCSVStreaming();
                if (!data) {
                    loadingDiv.innerHTML = '<div style="color: #f44336;">Error loading CSV</div>';
                    return;
                }

                // Wait for CSV to completely load
                while (!csvComplete) {
                    loadingDiv.innerHTML = '<div class="spinner"></div>Loading data... ' + csvData.length.toLocaleString() + ' rows loaded';
                    await new Promise(resolve => setTimeout(resolve, 200));
                }

                loadingDiv.innerHTML = '<div class="spinner"></div>Processing ' + csvData.length.toLocaleString() + ' data points...';

                // Process ALL data at once
                const processedData = await processWithWorker(csvData, null);
                
                console.log('[Histograms] Creating histograms with ' + processedData.length + ' total points');

                // Extract all values from complete dataset
                const radiusValues = processedData.map(r => r.solarRadius).filter(v => v !== null && v !== undefined);
                const periodValues = processedData.map(r => r.rotationalPeriod).filter(v => v !== null && v !== undefined);
                const ageValues = processedData.map(r => r.age).filter(v => v !== null && v !== undefined);
                const massValues = processedData.map(r => r.mass).filter(v => v !== null && v !== undefined);
                const tempValues = processedData.map(r => r.temperature).filter(v => v !== null && v !== undefined);
                const velocityValues = processedData.map(r => r.tangentialVelocity).filter(v => v !== null && v !== undefined);
                
                console.log('[Histograms] Value counts - radius: ' + radiusValues.length + ', period: ' + periodValues.length + ', age: ' + ageValues.length);
                
                const spinCounts = { up: 0, down: 0, none: 0 };
                processedData.forEach(r => {
                    if (r.spin === 'up') spinCounts.up++;
                    else if (r.spin === 'down') spinCounts.down++;
                    else if (r.spin === 'none') spinCounts.none++;
                });

                // Create histograms
                console.log('[Histograms] Creating radius histogram...');
                try {
                    await Plotly.newPlot('hist-radius', [{
                        x: radiusValues,
                        type: 'histogram',
                        nbinsx: 50,
                        marker: { color: '#4a9eff' },
                        name: 'Radius'
                    }], {
                        title: 'Solar Radius Distribution',
                        xaxis: { title: 'Solar Radius (R☉)', gridcolor: '#333' },
                        yaxis: { title: 'Count', gridcolor: '#333' },
                        paper_bgcolor: '#1a1a1a',
                        plot_bgcolor: '#1a1a1a',
                        font: { color: '#fff' },
                        height: 380
                    }, { responsive: true });
                    console.log('[Histograms] Radius histogram created');
                } catch (e) {
                    console.error('[Histograms] Error creating radius histogram:', e);
                }

                try {
                    await Plotly.newPlot('hist-period', [{
                    x: periodValues,
                    type: 'histogram',
                    nbinsx: 50,
                    marker: { color: '#ff6b6b' },
                    name: 'Period'
                }], {
                    title: 'Rotational Period Distribution',
                    xaxis: { title: 'Rotational Period (days)', gridcolor: '#333' },
                    yaxis: { title: 'Count', gridcolor: '#333' },
                    paper_bgcolor: '#1a1a1a',
                    plot_bgcolor: '#1a1a1a',
                    font: { color: '#fff' },
                    height: 380
                }, { responsive: true });
                    console.log('[Histograms] Period histogram created');
                } catch (e) {
                    console.error('[Histograms] Error creating period histogram:', e);
                }

                try {
                    await Plotly.newPlot('hist-age', [{
                    x: ageValues,
                    type: 'histogram',
                    nbinsx: 50,
                    marker: { color: '#51cf66' },
                    name: 'Age'
                }], {
                    title: 'Age Distribution',
                    xaxis: { title: 'Age (Myr)', gridcolor: '#333' },
                    yaxis: { title: 'Count', gridcolor: '#333' },
                    paper_bgcolor: '#1a1a1a',
                    plot_bgcolor: '#1a1a1a',
                    font: { color: '#fff' },
                    height: 380
                }, { responsive: true });
                    console.log('[Histograms] Age histogram created');
                } catch (e) {
                    console.error('[Histograms] Error creating age histogram:', e);
                }

                try {
                    await Plotly.newPlot('hist-mass', [{
                    x: massValues,
                    type: 'histogram',
                    nbinsx: 50,
                    marker: { color: '#ffd43b' },
                    name: 'Mass'
                }], {
                    title: 'Mass Distribution',
                    xaxis: { title: 'Mass (M☉)', gridcolor: '#333' },
                    yaxis: { title: 'Count', gridcolor: '#333' },
                    shapes: [
                        {
                            type: 'line',
                            x0: 1.4,
                            x1: 1.4,
                            y0: 0,
                            y1: 1,
                            yref: 'paper',
                            line: { color: '#00ccff', width: 2, dash: 'dot' }
                        },
                        {
                            type: 'line',
                            x0: 2.5,
                            x1: 2.5,
                            y0: 0,
                            y1: 1,
                            yref: 'paper',
                            line: { color: '#9933ff', width: 2, dash: 'dot' }
                        }
                    ],
                    paper_bgcolor: '#1a1a1a',
                    plot_bgcolor: '#1a1a1a',
                    font: { color: '#fff' },
                    height: 380
                }, { responsive: true });
                    console.log('[Histograms] Mass histogram created');
                } catch (e) {
                    console.error('[Histograms] Error creating mass histogram:', e);
                }

                try {
                    await Plotly.newPlot('hist-temperature', [{
                    x: tempValues,
                    type: 'histogram',
                    nbinsx: 50,
                    marker: { color: '#ff8787' },
                    name: 'Temperature'
                }], {
                    title: 'Temperature Distribution',
                    xaxis: { title: 'Temperature (K)', gridcolor: '#333' },
                    yaxis: { title: 'Count', gridcolor: '#333' },
                    paper_bgcolor: '#1a1a1a',
                    plot_bgcolor: '#1a1a1a',
                    font: { color: '#fff' },
                    height: 380
                }, { responsive: true });
                    console.log('[Histograms] Temperature histogram created');
                } catch (e) {
                    console.error('[Histograms] Error creating temperature histogram:', e);
                }

                try {
                    await Plotly.newPlot('hist-velocity', [{
                    x: velocityValues,
                    type: 'histogram',
                    nbinsx: 50,
                    marker: { color: '#b197fc' },
                    name: 'Velocity'
                }], {
                    title: 'Tangential Velocity Distribution',
                    xaxis: { title: 'Velocity (km/s)', gridcolor: '#333' },
                    yaxis: { title: 'Count', gridcolor: '#333' },
                    shapes: [
                        {
                            type: 'line',
                            x0: 299792,
                            x1: 299792,
                            y0: 0,
                            y1: 1,
                            yref: 'paper',
                            line: { color: '#ff0000', width: 2, dash: 'dash' }
                        }
                    ],
                    paper_bgcolor: '#1a1a1a',
                    plot_bgcolor: '#1a1a1a',
                    font: { color: '#fff' },
                    height: 380
                }, { responsive: true });
                    console.log('[Histograms] Velocity histogram created');
                } catch (e) {
                    console.error('[Histograms] Error creating velocity histogram:', e);
                }

                try {
                    await Plotly.newPlot('hist-spin', [{
                        x: ['Up', 'Down', 'None'],
                        y: [spinCounts.up, spinCounts.down, spinCounts.none],
                        type: 'bar',
                        marker: { 
                            color: ['#00FF00', '#FF0000', '#FFA500']
                        },
                        name: 'Spin'
                    }], {
                        title: 'Spin State Distribution',
                        xaxis: { title: 'Spin State', gridcolor: '#333' },
                        yaxis: { title: 'Count', gridcolor: '#333' },
                        paper_bgcolor: '#1a1a1a',
                        plot_bgcolor: '#1a1a1a',
                        font: { color: '#fff' },
                        height: 380
                    }, { responsive: true });
                    console.log('[Histograms] Spin histogram created');
                } catch (e) {
                    console.error('[Histograms] Error creating spin histogram:', e);
                }

                console.log('[Histograms] All histograms created with ' + processedData.length + ' total points');
                loadingDiv.innerHTML = '<div style="color: #4a9eff; font-weight: 500;">✓ Loaded ' + csvData.length.toLocaleString() + ' data points</div>';
                loadedTabs.add(tabIndex);

            } catch (error) {
                console.error('[Histograms] Error:', error);
                loadingDiv.innerHTML = '<div style="color: #f44336;">Error loading histograms: ' + error.message + '</div>';
            }
        }

        async function loadAndStreamData(tabIndex) {
            const loadingDiv = document.getElementById('loading-' + tabIndex);
            const plotConfig = plots[tabIndex];
            const startTime = performance.now();

            console.log('[Plot ' + tabIndex + '] Starting load for: ' + plotConfig.title);

            try {
                const data = await loadCSVStreaming();
                if (!data) {
                    loadingDiv.innerHTML = '<div style="color: #f44336;">Error loading CSV</div>';
                    return;
                }

                const plotDiv = document.getElementById('plot-' + tabIndex);

                // Initialize worker if not exists
                if (!dataWorker) {
                    dataWorker = createDataWorker();
                }

                const xField = plotConfig.x;
                const yField = plotConfig.y;
                const colorField = plotConfig.color;

                // Track min/max x and y values for physics constraint lines
                let dataXMin = Infinity;
                let dataXMax = -Infinity;
                let dataYMin = Infinity;
                let dataYMax = -Infinity;

                // Process initial chunk with worker
                const initialData = data.slice(0, INITIAL_CHUNK_SIZE);
                const processedInitial = await processWithWorker(initialData, null);

                // Update min/max from initial data
                processedInitial.forEach(r => {
                    const xVal = r[xField];
                    const yVal = r[yField];
                    if (xVal !== null && xVal !== undefined && !isNaN(xVal)) {
                        dataXMin = Math.min(dataXMin, xVal);
                        dataXMax = Math.max(dataXMax, xVal);
                    }
                    if (yVal !== null && yVal !== undefined && !isNaN(yVal)) {
                        dataYMin = Math.min(dataYMin, yVal);
                        dataYMax = Math.max(dataYMax, yVal);
                    }
                });

                // Downsample for initial display to reduce overlapping points
                const sampledInitial = downsampleForDisplay(processedInitial, xField, yField, colorField, 800);

                // Calculate color range from ALL processed data (not just sampled) for consistent colors
                const colorVals = processedInitial.map(r => r[colorField]).filter(v => v !== null && v !== undefined && v > 0);
                let colorMin = Math.min(...colorVals);
                let colorMax = Math.max(...colorVals);

                const trace = {
                    x: sampledInitial.map(r => r[xField]),
                    y: sampledInitial.map(r => r[yField]),
                    mode: 'markers',
                    type: 'scattergl',
                    marker: {
                        size: 4,
                        color: sampledInitial.map(r => r[colorField]),
                        colorscale: plotConfig.colorscale === 'viridis' ? 'Viridis' : 'Plasma',
                        showscale: true,
                        colorbar: { title: plotConfig.colorbar },
                        cmin: colorMin,
                        cmax: colorMax
                    },
                    text: sampledInitial.map(r => r.hoverText),
                    customdata: sampledInitial.map(r => r.system),
                    hoverinfo: 'text'
                };

                // Determine axis types based on field names
                // Log scale for everything EXCEPT age, mass, and radius (solarRadius)
                const xType = (plotConfig.x === 'age' || plotConfig.x === 'mass' || plotConfig.x === 'solarRadius') ? 'linear' : 'log';
                const yType = (plotConfig.y === 'age' || plotConfig.y === 'mass' || plotConfig.y === 'solarRadius') ? 'linear' : 'log';

                const layout = {
                    title: plotConfig.title,
                    xaxis: { title: plotConfig.xlabel, type: xType },
                    yaxis: { title: plotConfig.ylabel, type: yType },
                    paper_bgcolor: '#1a1a1a',
                    plot_bgcolor: '#1a1a1a',
                    font: { color: '#fff' },
                    hovermode: 'closest',
                    autosize: true,
                    height: 700,
                    margin: { l: 80, r: 80, t: 80, b: 80 },
                    showlegend: false
                };

                // Add reference lines and annotations
                if (plotConfig.reference_line) {
                    layout.shapes = [{
                        type: 'line',
                        x0: Math.min(...trace.x),
                        x1: Math.max(...trace.x),
                        y0: plotConfig.reference_line,
                        y1: plotConfig.reference_line,
                        line: { color: '#00ff00', width: 2, dash: 'dash' }
                    }];
                }

                // Add physics constraint lines for Mass vs Radius plot (plot index 5)
                if (tabIndex === 5) {
                    // Schwarzschild radius: R = 2.95 km * M (solar masses) / 696000 km = 0.00000424 * M
                    const schwarzschildSlope = 0.00000424;

                    // Calculate Schwarzschild line endpoints constrained to data Y bounds
                    let schwY0 = dataXMin * schwarzschildSlope;
                    let schwY1 = dataXMax * schwarzschildSlope;
                    let schwX0 = dataXMin;
                    let schwX1 = dataXMax;

                    // Clip to Y bounds
                    if (schwY0 < dataYMin) {
                        schwX0 = dataYMin / schwarzschildSlope;
                        schwY0 = dataYMin;
                    }
                    if (schwY1 > dataYMax) {
                        schwX1 = dataYMax / schwarzschildSlope;
                        schwY1 = dataYMax;
                    }

                    layout.shapes = [
                        // Schwarzschild radius - dotted red diagonal
                        {
                            type: 'line',
                            x0: schwX0,
                            x1: schwX1,
                            y0: schwY0,
                            y1: schwY1,
                            line: { color: '#ff0000', width: 2.5, dash: 'dot' },
                            layer: 'below',
                            xref: 'x',
                            yref: 'y'
                        }
                    ];

                    // Add Chandrasekhar limit line if 1.4 is within data range
                    if (1.4 >= dataXMin && 1.4 <= dataXMax) {
                        layout.shapes.push({
                            type: 'line',
                            x0: 1.4,
                            x1: 1.4,
                            y0: dataYMin,
                            y1: dataYMax,
                            line: { color: '#00ccff', width: 2.5, dash: 'dot' },
                            layer: 'below',
                            xref: 'x',
                            yref: 'y'
                        });
                    }

                    // Only add TOV limit line if 2.5 is within data range
                    if (2.5 >= dataXMin && 2.5 <= dataXMax) {
                        layout.shapes.push({
                            type: 'line',
                            x0: 2.5,
                            x1: 2.5,
                            y0: dataYMin,
                            y1: dataYMax,
                            line: { color: '#9933ff', width: 2.5, dash: 'dot' },
                            layer: 'below',
                            xref: 'x',
                            yref: 'y'
                        });
                    }
                }

                // Add physics constraint lines for Rotational Period vs Mass plot (plot index 7)
                if (tabIndex === 7) {
                    layout.shapes = [];

                    // Add Chandrasekhar limit line if 1.4 is within data range
                    if (1.4 >= dataXMin && 1.4 <= dataXMax) {
                        layout.shapes.push({
                            type: 'line',
                            x0: 1.4,
                            x1: 1.4,
                            y0: dataYMin,
                            y1: dataYMax,
                            line: { color: '#00ccff', width: 2.5, dash: 'dot' },
                            layer: 'below',
                            xref: 'x',
                            yref: 'y'
                        });
                    }

                    // Add TOV limit line if 2.5 is within data range
                    if (2.5 >= dataXMin && 2.5 <= dataXMax) {
                        layout.shapes.push({
                            type: 'line',
                            x0: 2.5,
                            x1: 2.5,
                            y0: dataYMin,
                            y1: dataYMax,
                            line: { color: '#9933ff', width: 2.5, dash: 'dot' },
                            layer: 'below',
                            xref: 'x',
                            yref: 'y'
                        });
                    }
                }

                // Add physics constraint lines for Mass vs Age plot (plot index 8)
                if (tabIndex === 8) {
                    layout.shapes = [];

                    // Add Chandrasekhar limit line if 1.4 is within data range (horizontal line)
                    if (1.4 >= dataYMin && 1.4 <= dataYMax) {
                        layout.shapes.push({
                            type: 'line',
                            x0: dataXMin,
                            x1: dataXMax,
                            y0: 1.4,
                            y1: 1.4,
                            line: { color: '#00ccff', width: 2.5, dash: 'dot' },
                            layer: 'below',
                            xref: 'x',
                            yref: 'y'
                        });
                    }

                    // Add TOV limit line if 2.5 is within data range (horizontal line)
                    if (2.5 >= dataYMin && 2.5 <= dataYMax) {
                        layout.shapes.push({
                            type: 'line',
                            x0: dataXMin,
                            x1: dataXMax,
                            y0: 2.5,
                            y1: 2.5,
                            line: { color: '#9933ff', width: 2.5, dash: 'dot' },
                            layer: 'below',
                            xref: 'x',
                            yref: 'y'
                        });
                    }
                }

                // Add physics constraint lines for Tangential Velocity vs Mass plot (plot index 9)
                if (tabIndex === 9) {
                    layout.shapes = layout.shapes || [];
                    const SPEED_OF_LIGHT = 299792; // km/s

                    // Speed of light line is already added via reference_line property
                    // Add mass limit lines

                    // Add Chandrasekhar limit line if 1.4 is within data range (vertical line)
                    if (1.4 >= dataXMin && 1.4 <= dataXMax) {
                        layout.shapes.push({
                            type: 'line',
                            x0: 1.4,
                            x1: 1.4,
                            y0: dataYMin,
                            y1: dataYMax,
                            line: { color: '#00ccff', width: 2.5, dash: 'dot' },
                            layer: 'below',
                            xref: 'x',
                            yref: 'y'
                        });
                    }

                    // Add TOV limit line if 2.5 is within data range (vertical line)
                    if (2.5 >= dataXMin && 2.5 <= dataXMax) {
                        layout.shapes.push({
                            type: 'line',
                            x0: 2.5,
                            x1: 2.5,
                            y0: dataYMin,
                            y1: dataYMax,
                            line: { color: '#9933ff', width: 2.5, dash: 'dot' },
                            layer: 'below',
                            xref: 'x',
                            yref: 'y'
                        });
                    }
                }

                // Add physics constraint lines for P-Pdot diagram (plot index 6)
                if (tabIndex === 6) {
                    layout.shapes = [];
                    layout.annotations = [];

                    // Death line: log(Pdot) ≈ -15.5 + 0.5 * log(P)
                    // Convert to actual values: Pdot = 10^(-15.5) * P^0.5
                    // P is in days, need to convert to seconds for physics
                    const pRangeSeconds = [dataXMin * 86400, dataXMax * 86400];
                    const deathLinePoints = [];
                    for (let logP = Math.log10(pRangeSeconds[0]); logP <= Math.log10(pRangeSeconds[1]); logP += 0.1) {
                        const pSeconds = Math.pow(10, logP);
                        const pdot = Math.pow(10, -15.5 + 0.5 * logP);
                        deathLinePoints.push({ p: pSeconds / 86400, pdot: pdot });
                    }

                    // Add death line as a series of connected segments
                    for (let i = 0; i < deathLinePoints.length - 1; i++) {
                        layout.shapes.push({
                            type: 'line',
                            x0: deathLinePoints[i].p,
                            x1: deathLinePoints[i + 1].p,
                            y0: deathLinePoints[i].pdot,
                            y1: deathLinePoints[i + 1].pdot,
                            line: { color: '#ff0000', width: 2.5, dash: 'dash' },
                            layer: 'below'
                        });
                    }

                    // Add age contour lines: Pdot = P / (2 * age)
                    // Age in seconds, P in seconds, Pdot is dimensionless (s/s)
                    const ageContours = [
                        { years: 1e3, label: '1 kyr', color: '#888888' },
                        { years: 1e6, label: '1 Myr', color: '#888888' },
                        { years: 1e9, label: '1 Gyr', color: '#888888' }
                    ];

                    ageContours.forEach(({ years, label, color }) => {
                        const ageSeconds = years * 365.25 * 86400;
                        const ageLinePoints = [];

                        for (let logP = Math.log10(pRangeSeconds[0]); logP <= Math.log10(pRangeSeconds[1]); logP += 0.1) {
                            const pSeconds = Math.pow(10, logP);
                            const pdot = pSeconds / (2 * ageSeconds);
                            ageLinePoints.push({ p: pSeconds / 86400, pdot: pdot });
                        }

                        // Add age line as connected segments
                        for (let i = 0; i < ageLinePoints.length - 1; i++) {
                            layout.shapes.push({
                                type: 'line',
                                x0: ageLinePoints[i].p,
                                x1: ageLinePoints[i + 1].p,
                                y0: ageLinePoints[i].pdot,
                                y1: ageLinePoints[i + 1].pdot,
                                line: { color: color, width: 1.5, dash: 'dot' },
                                layer: 'below'
                            });
                        }

                        // Add label annotation at the right end
                        const lastPoint = ageLinePoints[ageLinePoints.length - 1];
                        layout.annotations.push({
                            x: Math.log10(lastPoint.p),
                            y: Math.log10(lastPoint.pdot),
                            text: label,
                            showarrow: false,
                            font: { color: color, size: 11 },
                            xanchor: 'left',
                            xshift: 5
                        });
                    });
                }

                Plotly.newPlot(plotDiv, [trace], layout, {
                    responsive: true,
                    displayModeBar: true
                });

                // Add legend key for physics constraint lines
                if (tabIndex === 5) {
                    layout.annotations = layout.annotations || [];
                    let xPos = 0.02;

                    layout.annotations.push({
                        x: xPos,
                        y: -0.15,
                        xref: 'paper',
                        yref: 'paper',
                        text: '⋯⋯⋯ Schwarzschild Radius',
                        showarrow: false,
                        font: { color: '#ff0000', size: 12 },
                        xanchor: 'left',
                        yanchor: 'top',
                        bgcolor: 'rgba(0,0,0,0.5)',
                        borderpad: 4
                    });

                    if (1.4 >= dataXMin && 1.4 <= dataXMax) {
                        xPos += 0.25;
                        layout.annotations.push({
                            x: xPos,
                            y: -0.15,
                            xref: 'paper',
                            yref: 'paper',
                            text: '⋯⋯⋯ Chandrasekhar Limit (1.4 M☉)',
                            showarrow: false,
                            font: { color: '#00ccff', size: 12 },
                            xanchor: 'left',
                            yanchor: 'top',
                            bgcolor: 'rgba(0,0,0,0.5)',
                            borderpad: 4
                        });
                    }

                    if (2.5 >= dataXMin && 2.5 <= dataXMax) {
                        xPos += 0.35;
                        layout.annotations.push({
                            x: xPos,
                            y: -0.15,
                            xref: 'paper',
                            yref: 'paper',
                            text: '⋯⋯⋯ TOV Limit (2.5 M☉)',
                            showarrow: false,
                            font: { color: '#9933ff', size: 12 },
                            xanchor: 'left',
                            yanchor: 'top',
                            bgcolor: 'rgba(0,0,0,0.5)',
                            borderpad: 4
                        });
                    }
                }

                if (tabIndex === 6) {
                    layout.annotations = layout.annotations || [];
                    layout.annotations.push({
                        x: 0.02,
                        y: -0.15,
                        xref: 'paper',
                        yref: 'paper',
                        text: '--- Death Line',
                        showarrow: false,
                        font: { color: '#ff0000', size: 12 },
                        xanchor: 'left',
                        yanchor: 'top',
                        bgcolor: 'rgba(0,0,0,0.5)',
                        borderpad: 4
                    });
                    layout.annotations.push({
                        x: 0.22,
                        y: -0.15,
                        xref: 'paper',
                        yref: 'paper',
                        text: '⋯⋯⋯ Constant Age Lines',
                        showarrow: false,
                        font: { color: '#888888', size: 12 },
                        xanchor: 'left',
                        yanchor: 'top',
                        bgcolor: 'rgba(0,0,0,0.5)',
                        borderpad: 4
                    });
                }

                if (tabIndex === 7) {
                    layout.annotations = layout.annotations || [];
                    let xPos = 0.02;

                    if (1.4 >= dataXMin && 1.4 <= dataXMax) {
                        layout.annotations.push({
                            x: xPos,
                            y: -0.15,
                            xref: 'paper',
                            yref: 'paper',
                            text: '⋯⋯⋯ Chandrasekhar Limit (1.4 M☉)',
                            showarrow: false,
                            font: { color: '#00ccff', size: 12 },
                            xanchor: 'left',
                            yanchor: 'top',
                            bgcolor: 'rgba(0,0,0,0.5)',
                            borderpad: 4
                        });
                        xPos += 0.35;
                    }

                    if (2.5 >= dataXMin && 2.5 <= dataXMax) {
                        layout.annotations.push({
                            x: xPos,
                            y: -0.15,
                            xref: 'paper',
                            yref: 'paper',
                            text: '⋯⋯⋯ TOV Limit (2.5 M☉)',
                            showarrow: false,
                            font: { color: '#9933ff', size: 12 },
                            xanchor: 'left',
                            yanchor: 'top',
                            bgcolor: 'rgba(0,0,0,0.5)',
                            borderpad: 4
                        });
                    }
                }

                if (tabIndex === 8) {
                    layout.annotations = layout.annotations || [];
                    let xPos = 0.02;

                    if (1.4 >= dataYMin && 1.4 <= dataYMax) {
                        layout.annotations.push({
                            x: xPos,
                            y: -0.15,
                            xref: 'paper',
                            yref: 'paper',
                            text: '⋯⋯⋯ Chandrasekhar Limit (1.4 M☉)',
                            showarrow: false,
                            font: { color: '#00ccff', size: 12 },
                            xanchor: 'left',
                            yanchor: 'top',
                            bgcolor: 'rgba(0,0,0,0.5)',
                            borderpad: 4
                        });
                        xPos += 0.35;
                    }

                    if (2.5 >= dataYMin && 2.5 <= dataYMax) {
                        layout.annotations.push({
                            x: xPos,
                            y: -0.15,
                            xref: 'paper',
                            yref: 'paper',
                            text: '⋯⋯⋯ TOV Limit (2.5 M☉)',
                            showarrow: false,
                            font: { color: '#9933ff', size: 12 },
                            xanchor: 'left',
                            yanchor: 'top',
                            bgcolor: 'rgba(0,0,0,0.5)',
                            borderpad: 4
                        });
                    }
                }

                if (tabIndex === 9) {
                    layout.annotations = layout.annotations || [];
                    layout.annotations.push({
                        x: 0.5,
                        y: -0.15,
                        xref: 'paper',
                        yref: 'paper',
                        text: 'Chandrasekhar limit (1.4 M☉) | TOV limit (2.5 M☉) | Speed of light (c)',
                        showarrow: false,
                        font: { color: '#aaa', size: 11 },
                        xanchor: 'center',
                        yanchor: 'top'
                    });
                }

                // Add click handler for navigation to Canonn signals
                plotDiv.on('plotly_click', function (data) {
                    const point = data.points[0];
                    if (point && point.customdata) {
                        const systemName = point.customdata;
                        const url = 'https://signals.canonn.tech/?system=' + encodeURIComponent(systemName);
                        console.log('[Plot] Opening system:', systemName, 'at', url);
                        window.open(url, '_blank');
                    }
                });

                let currentOffset = INITIAL_CHUNK_SIZE;
                loadingDiv.innerHTML = '<div class="spinner"></div>Streaming data as it loads...';

                // Update progress periodically using requestIdleCallback
                const progressInterval = setInterval(() => {
                    if (csvData.length > INITIAL_CHUNK_SIZE) {
                        requestIdleCallback(() => {
                            loadingDiv.innerHTML = '<div class="spinner"></div>Loaded ' + Math.min(currentOffset, csvData.length).toLocaleString() + ' of 3,318,091 points...';
                        });
                    }
                }, 1000); // Reduced frequency from 500ms to 1000ms

                (async () => {
                    try {
                        let offset = INITIAL_CHUNK_SIZE;
                        let updateCount = 0;
                        let pendingData = [];
                        let isUpdating = false;

                        console.log('[Plot ' + tabIndex + '] Starting streaming loop, initial csvData.length:', csvData.length);

                        // Optimized batch updates - non-blocking
                        let lastUpdateTime = performance.now();
                        const flushPending = async () => {
                            if (pendingData.length === 0 || isUpdating) return;

                            isUpdating = true;
                            const dataToUpdate = pendingData.slice();
                            const pointCount = pendingData.length;
                            pendingData = [];

                            const updateStart = performance.now();
                            console.log('[Plot ' + tabIndex + '] Update #' + (updateCount + 1) + ': Adding ' + pointCount.toLocaleString() + ' points (total will be ~' + (offset + pointCount).toLocaleString() + ')');

                            await new Promise(resolve => {
                                Plotly.extendTraces(plotDiv, {
                                    x: [dataToUpdate.map(r => r[xField])],
                                    y: [dataToUpdate.map(r => r[yField])],
                                    'marker.color': [dataToUpdate.map(r => r[colorField])],
                                    text: [dataToUpdate.map(r => r.hoverText)],
                                    customdata: [dataToUpdate.map(r => r.system)]
                                }, [0]);
                                requestAnimationFrame(resolve);
                            });

                            const updateDuration = performance.now() - updateStart;
                            console.log('[Plot ' + tabIndex + '] Update #' + (updateCount + 1) + ' completed in ' + updateDuration.toFixed(1) + 'ms');

                            updateCount++;
                            lastUpdateTime = performance.now();
                            isUpdating = false;

                            // Trigger next update if data accumulated while updating
                            if (pendingData.length >= UPDATE_BATCH_SIZE) {
                                flushPending();
                            }
                        };

                        while (true) {
                            // Wait for new data
                            while (csvData.length <= offset && !csvComplete) {
                                await new Promise(resolve => setTimeout(resolve, 100));
                            }

                            if (offset >= csvData.length) break;

                            const end = Math.min(offset + CHUNK_SIZE, csvData.length);
                            const chunk = csvData.slice(offset, end);

                            if (chunk.length > 0) {
                                // Process chunk in worker
                                const processedChunk = await processWithWorker(chunk, null);

                                // Update min/max from chunk
                                processedChunk.forEach(r => {
                                    const xVal = r[xField];
                                    const yVal = r[yField];
                                    if (xVal !== null && xVal !== undefined && !isNaN(xVal)) {
                                        dataXMin = Math.min(dataXMin, xVal);
                                        dataXMax = Math.max(dataXMax, xVal);
                                    }
                                    if (yVal !== null && yVal !== undefined && !isNaN(yVal)) {
                                        dataYMin = Math.min(dataYMin, yVal);
                                        dataYMax = Math.max(dataYMax, yVal);
                                    }
                                });

                                // Downsample chunk to reduce overlaps
                                const sampledChunk = downsampleForDisplay(processedChunk, xField, yField, colorField, 800);

                                // Add to pending batch (store full rows)
                                pendingData.push(...sampledChunk);

                                // Trigger update when batch size reached (non-blocking)
                                if (pendingData.length >= UPDATE_BATCH_SIZE && !isUpdating) {
                                    flushPending(); // Fire and forget
                                }
                            }

                            currentOffset = offset = end;

                            if (offset % 100000 === 0) {
                                console.log('[Plot ' + tabIndex + '] Processed ' + offset.toLocaleString() + ' rows');
                            }

                            // Yield control to browser between chunks
                            await new Promise(resolve => setTimeout(resolve, 5));
                        }

                        // Flush any remaining data
                        await flushPending();

                        // Wait for any final update to complete
                        while (isUpdating) {
                            await new Promise(resolve => setTimeout(resolve, 50));
                        }

                        console.log('[Plot ' + tabIndex + '] Streaming loop finished, final csvData.length:', csvData.length);

                        // Update physics constraint lines with final data bounds
                        if (tabIndex === 5) {
                            const schwarzschildSlope = 0.00000424;

                            // Calculate Schwarzschild line endpoints constrained to final data Y bounds
                            let schwY0 = dataXMin * schwarzschildSlope;
                            let schwY1 = dataXMax * schwarzschildSlope;
                            let schwX0 = dataXMin;
                            let schwX1 = dataXMax;

                            // Clip to Y bounds
                            if (schwY0 < dataYMin) {
                                schwX0 = dataYMin / schwarzschildSlope;
                                schwY0 = dataYMin;
                            }
                            if (schwY1 > dataYMax) {
                                schwX1 = dataYMax / schwarzschildSlope;
                                schwY1 = dataYMax;
                            }

                            const finalShapes = [
                                {
                                    type: 'line',
                                    x0: schwX0,
                                    x1: schwX1,
                                    y0: schwY0,
                                    y1: schwY1,
                                    line: { color: '#ff0000', width: 2.5, dash: 'dot' },
                                    layer: 'below',
                                    xref: 'x',
                                    yref: 'y'
                                }
                            ];

                            if (1.4 >= dataXMin && 1.4 <= dataXMax) {
                                finalShapes.push({
                                    type: 'line',
                                    x0: 1.4,
                                    x1: 1.4,
                                    y0: dataYMin,
                                    y1: dataYMax,
                                    line: { color: '#00ccff', width: 2.5, dash: 'dot' },
                                    layer: 'below',
                                    xref: 'x',
                                    yref: 'y'
                                });
                            }

                            if (2.5 >= dataXMin && 2.5 <= dataXMax) {
                                finalShapes.push({
                                    type: 'line',
                                    x0: 2.5,
                                    x1: 2.5,
                                    y0: dataYMin,
                                    y1: dataYMax,
                                    line: { color: '#9933ff', width: 2.5, dash: 'dot' },
                                    layer: 'below',
                                    xref: 'x',
                                    yref: 'y'
                                });
                            }

                            Plotly.relayout(plotDiv, { shapes: finalShapes });
                            console.log('[Plot ' + tabIndex + '] Updated physics lines to final bounds: X[' + dataXMin + ', ' + dataXMax + '], Y[' + dataYMin + ', ' + dataYMax + ']');
                        }

                        // Update P-Pdot diagram lines with final data bounds
                        if (tabIndex === 6) {
                            const finalShapes = [];
                            const finalAnnotations = [];

                            // Death line with final bounds
                            const pRangeSeconds = [dataXMin * 86400, dataXMax * 86400];
                            const deathLinePoints = [];
                            for (let logP = Math.log10(pRangeSeconds[0]); logP <= Math.log10(pRangeSeconds[1]); logP += 0.1) {
                                const pSeconds = Math.pow(10, logP);
                                const pdot = Math.pow(10, -15.5 + 0.5 * logP);
                                deathLinePoints.push({ p: pSeconds / 86400, pdot: pdot });
                            }

                            for (let i = 0; i < deathLinePoints.length - 1; i++) {
                                finalShapes.push({
                                    type: 'line',
                                    x0: deathLinePoints[i].p,
                                    x1: deathLinePoints[i + 1].p,
                                    y0: deathLinePoints[i].pdot,
                                    y1: deathLinePoints[i + 1].pdot,
                                    line: { color: '#ff0000', width: 2.5, dash: 'dash' },
                                    layer: 'below'
                                });
                            }

                            // Age contours with final bounds
                            const ageContours = [
                                { years: 1e3, label: '1 kyr', color: '#888888' },
                                { years: 1e6, label: '1 Myr', color: '#888888' },
                                { years: 1e9, label: '1 Gyr', color: '#888888' }
                            ];

                            ageContours.forEach(({ years, label, color }) => {
                                const ageSeconds = years * 365.25 * 86400;
                                const ageLinePoints = [];

                                for (let logP = Math.log10(pRangeSeconds[0]); logP <= Math.log10(pRangeSeconds[1]); logP += 0.1) {
                                    const pSeconds = Math.pow(10, logP);
                                    const pdot = pSeconds / (2 * ageSeconds);
                                    ageLinePoints.push({ p: pSeconds / 86400, pdot: pdot });
                                }

                                for (let i = 0; i < ageLinePoints.length - 1; i++) {
                                    finalShapes.push({
                                        type: 'line',
                                        x0: ageLinePoints[i].p,
                                        x1: ageLinePoints[i + 1].p,
                                        y0: ageLinePoints[i].pdot,
                                        y1: ageLinePoints[i + 1].pdot,
                                        line: { color: color, width: 1.5, dash: 'dot' },
                                        layer: 'below'
                                    });
                                }

                                const lastPoint = ageLinePoints[ageLinePoints.length - 1];
                                finalAnnotations.push({
                                    x: Math.log10(lastPoint.p),
                                    y: Math.log10(lastPoint.pdot),
                                    text: label,
                                    showarrow: false,
                                    font: { color: color, size: 11 },
                                    xanchor: 'left',
                                    xshift: 5
                                });
                            });

                            Plotly.relayout(plotDiv, { shapes: finalShapes, annotations: finalAnnotations });
                            console.log('[Plot ' + tabIndex + '] Updated P-Pdot physics lines to final bounds');
                        }

                        // Update Rotational Period vs Mass plot lines with final data bounds (plot index 7)
                        if (tabIndex === 7) {
                            const finalShapes = [];

                            if (1.4 >= dataXMin && 1.4 <= dataXMax) {
                                finalShapes.push({
                                    type: 'line',
                                    x0: 1.4,
                                    x1: 1.4,
                                    y0: dataYMin,
                                    y1: dataYMax,
                                    line: { color: '#00ccff', width: 2.5, dash: 'dot' },
                                    layer: 'below',
                                    xref: 'x',
                                    yref: 'y'
                                });
                            }

                            if (2.5 >= dataXMin && 2.5 <= dataXMax) {
                                finalShapes.push({
                                    type: 'line',
                                    x0: 2.5,
                                    x1: 2.5,
                                    y0: dataYMin,
                                    y1: dataYMax,
                                    line: { color: '#9933ff', width: 2.5, dash: 'dot' },
                                    layer: 'below',
                                    xref: 'x',
                                    yref: 'y'
                                });
                            }

                            Plotly.relayout(plotDiv, { shapes: finalShapes });
                            console.log('[Plot ' + tabIndex + '] Updated mass limit lines to final bounds');
                        }

                        // Update Mass vs Age plot lines with final data bounds (plot index 8)
                        if (tabIndex === 8) {
                            const finalShapes = [];

                            if (1.4 >= dataYMin && 1.4 <= dataYMax) {
                                finalShapes.push({
                                    type: 'line',
                                    x0: dataXMin,
                                    x1: dataXMax,
                                    y0: 1.4,
                                    y1: 1.4,
                                    line: { color: '#00ccff', width: 2.5, dash: 'dot' },
                                    layer: 'below',
                                    xref: 'x',
                                    yref: 'y'
                                });
                            }

                            if (2.5 >= dataYMin && 2.5 <= dataYMax) {
                                finalShapes.push({
                                    type: 'line',
                                    x0: dataXMin,
                                    x1: dataXMax,
                                    y0: 2.5,
                                    y1: 2.5,
                                    line: { color: '#9933ff', width: 2.5, dash: 'dot' },
                                    layer: 'below',
                                    xref: 'x',
                                    yref: 'y'
                                });
                            }

                            Plotly.relayout(plotDiv, { shapes: finalShapes });
                            console.log('[Plot ' + tabIndex + '] Updated mass limit lines to final bounds');
                        }

                        // Update Tangential Velocity vs Mass plot lines with final data bounds (plot index 9)
                        if (tabIndex === 9) {
                            const finalShapes = [];
                            const finalAnnotations = [];
                            const SPEED_OF_LIGHT = 299792; // km/s

                            // Speed of light horizontal line
                            if (SPEED_OF_LIGHT >= dataYMin && SPEED_OF_LIGHT <= dataYMax) {
                                finalShapes.push({
                                    type: 'line',
                                    x0: dataXMin,
                                    x1: dataXMax,
                                    y0: SPEED_OF_LIGHT,
                                    y1: SPEED_OF_LIGHT,
                                    line: { color: '#ff0000', width: 2.5, dash: 'dash' },
                                    layer: 'below',
                                    xref: 'x',
                                    yref: 'y'
                                });
                            }

                            // Chandrasekhar limit (1.4 M☉)
                            if (1.4 >= dataXMin && 1.4 <= dataXMax) {
                                finalShapes.push({
                                    type: 'line',
                                    x0: 1.4,
                                    x1: 1.4,
                                    y0: dataYMin,
                                    y1: dataYMax,
                                    line: { color: '#00ccff', width: 2.5, dash: 'dot' },
                                    layer: 'below',
                                    xref: 'x',
                                    yref: 'y'
                                });
                            }

                            // TOV limit (2.5 M☉)
                            if (2.5 >= dataXMin && 2.5 <= dataXMax) {
                                finalShapes.push({
                                    type: 'line',
                                    x0: 2.5,
                                    x1: 2.5,
                                    y0: dataYMin,
                                    y1: dataYMax,
                                    line: { color: '#9933ff', width: 2.5, dash: 'dot' },
                                    layer: 'below',
                                    xref: 'x',
                                    yref: 'y'
                                });
                            }

                            // Add annotations
                            finalAnnotations.push({
                                x: 0.5,
                                y: -0.15,
                                xref: 'paper',
                                yref: 'paper',
                                text: 'Chandrasekhar limit (1.4 M☉) | TOV limit (2.5 M☉) | Speed of light (c)',
                                showarrow: false,
                                font: { color: '#aaa', size: 11 },
                                xanchor: 'center',
                                yanchor: 'top'
                            });

                            Plotly.relayout(plotDiv, { shapes: finalShapes, annotations: finalAnnotations });
                            console.log('[Plot ' + tabIndex + '] Updated velocity and mass limit lines to final bounds');
                        }

                        clearInterval(progressInterval);

                        // Calculate total points rendered
                        const totalPoints = csvData.length;
                        loadingDiv.innerHTML = '<div style="color: #4a9eff; font-weight: 500;">✓ Loaded ' + totalPoints.toLocaleString() + ' data points</div>';

                        loadedTabs.add(tabIndex);

                        const elapsed = ((performance.now() - startTime) / 1000).toFixed(1);
                        console.log('[Plot ' + tabIndex + '] Complete in ' + elapsed + 's with ' + updateCount + ' updates');
                    } catch (err) {
                        console.error('[Plot ' + tabIndex + '] Streaming error:', err);
                        loadingDiv.innerHTML = '<div style="color: #f44336;">Error streaming data: ' + err.message + '</div>';
                    }
                })();

            } catch (error) {
                console.error('[Plot ' + tabIndex + '] Error:', error);
                loadingDiv.innerHTML = '<div style="color: #f44336;">Error loading plot: ' + error.message + '</div>';
            }
        }

        window.addEventListener('DOMContentLoaded', () => {
            loadAndStreamData(0);
        });

        // Handle window resize to prevent plots from vanishing
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                for (let i = 0; i < plots.length; i++) {
                    const plotDiv = document.getElementById('plot-' + i);
                    if (plotDiv && plotDiv.data && plotDiv.layout) {
                        const container = plotDiv.parentElement;
                        const width = container.offsetWidth;
                        Plotly.relayout(plotDiv, {
                            width: width,
                            height: 700
                        });
                    }
                }
            }, 100);
        });
    </script>
</body>

</html>