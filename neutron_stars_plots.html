<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neutron Star Analysis</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
        }

        .header {
            background: #2d2d2d;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        h1 {
            font-size: 24px;
            font-weight: 600;
        }

        .subtitle {
            color: #888;
            font-size: 14px;
            margin-top: 5px;
        }

        .tabs {
            display: flex;
            background: #2d2d2d;
            padding: 0 20px;
            border-bottom: 1px solid #444;
            overflow-x: auto;
        }

        .tab {
            padding: 15px 25px;
            cursor: pointer;
            border: none;
            background: none;
            color: #888;
            font-size: 14px;
            font-weight: 500;
            white-space: nowrap;
            transition: all 0.2s;
            border-bottom: 3px solid transparent;
        }

        .tab:hover {
            color: #fff;
            background: rgba(255, 255, 255, 0.05);
        }

        .tab.active {
            color: #4a9eff;
            border-bottom-color: #4a9eff;
        }

        .tab-content {
            display: none;
            padding: 20px;
            animation: fadeIn 0.3s;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .plot-container {
            background: #2d2d2d;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            overflow-x: auto;
            position: relative;
        }

        .loading {
            text-align: center;
            padding: 40px 20px;
            color: #888;
            font-size: 13px;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(26, 26, 26, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(4px);
        }

        .loading-overlay .message {
            color: #4a9eff;
            font-size: 16px;
            font-weight: 500;
            margin-top: 20px;
        }

        .spinner {
            display: inline-block;
            border: 3px solid #444;
            border-top: 3px solid #4a9eff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 0.8s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .help {
            background: #2d2d2d;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 8px;
            font-size: 13px;
            color: #aaa;
        }

        .help strong {
            color: #4a9eff;
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>Neutron Star Analysis</h1>
        <div class="subtitle">Interactive controls: zoom, pan, box select | Data loads on-demand with streaming</div>
    </div>

    <div class="tabs">
        <button class="tab active" onclick="showTab(0)">Radius vs Rotational Period</button>
        <button class="tab" onclick="showTab(1)">Rotational Period vs Age</button>
        <button class="tab" onclick="showTab(2)">Radius vs Age</button>
        <button class="tab" onclick="showTab(3)">Tangential Velocity vs Age</button>
        <button class="tab" onclick="showTab(4)">Temperature vs Age</button>
        <button class="tab" onclick="showTab(5)">Mass vs Radius</button>
        <button class="tab" onclick="showTab(6)">P-Ṗ Diagram</button>
        <button class="tab" onclick="showTab(7)">Rotational Period vs Mass</button>
        <button class="tab" onclick="showTab(8)">Mass vs Age</button>
        <button class="tab" onclick="showTab(9)">Tangential Velocity vs Mass</button>
        <button class="tab" onclick="showTab(10)">Temperature vs Compactness</button>
        <button class="tab" onclick="showTab(11)">Rotational Period vs Compactness</button>
        <button class="tab" onclick="showTab(12)">Mass-Radius by Age Groups</button>
        <button class="tab" onclick="showTab(13)">Tangential Velocity vs Compactness</button>
        <button class="tab" onclick="showTab(14)">Age by Region</button>
        <button class="tab" onclick="showTab(15)">Average Age by Region</button>
        <button class="tab" onclick="showTab(16)">Histograms</button>
    </div>

    <div id="tab0" class="tab-content active">
        <div class="help"><strong>Controls:</strong> Zoom, pan, hover for details. This plot streams data as it loads.
        </div>
        <div class="plot-container">
            <div id="plot-0" style="width:100%;height:700px;"></div>
            <div class="loading" id="loading-0"></div>
        </div>
    </div>

    <div id="tab1" class="tab-content">
        <div class="help"><strong>Controls:</strong> Zoom, pan, hover for details. This plot streams data as it loads.
        </div>
        <div class="plot-container">
            <div id="plot-1" style="width:100%;height:700px;"></div>
            <div class="loading" id="loading-1"></div>
        </div>
    </div>

    <div id="tab2" class="tab-content">
        <div class="help"><strong>Controls:</strong> Zoom, pan, hover for details. This plot streams data as it loads.
        </div>
        <div class="plot-container">
            <div id="plot-2" style="width:100%;height:700px;"></div>
            <div class="loading" id="loading-2"></div>
        </div>
    </div>

    <div id="tab3" class="tab-content">
        <div class="help"><strong>Controls:</strong> Zoom, pan, hover for details. This plot streams data as it loads.
        </div>
        <div class="plot-container">
            <div id="plot-3" style="width:100%;height:700px;"></div>
            <div class="loading" id="loading-3"></div>
        </div>
    </div>

    <div id="tab4" class="tab-content">
        <div class="help"><strong>Controls:</strong> Zoom, pan, hover for details. This plot streams data as it loads.
        </div>
        <div class="plot-container">
            <div id="plot-4" style="width:100%;height:700px;"></div>
            <div class="loading" id="loading-4"></div>
        </div>
    </div>

    <div id="tab5" class="tab-content">
        <div class="help"><strong>Controls:</strong> Zoom, pan, hover for details. This plot streams data as it loads.
        </div>
        <div class="plot-container">
            <div id="plot-5" style="width:100%;height:700px;"></div>
            <div class="loading" id="loading-5"></div>
        </div>
    </div>

    <div id="tab6" class="tab-content">
        <div class="help"><strong>P-Ṗ Diagram:</strong> Classic pulsar diagram showing period vs period derivative. Red
            dashed line = death line (pulsars below cannot emit radio waves). Dotted lines = constant age contours.
        </div>
        <div class="plot-container">
            <div id="plot-6" style="width:100%;height:700px;"></div>
            <div class="loading" id="loading-6"></div>
        </div>
    </div>

    <div id="tab7" class="tab-content">
        <div class="help"><strong>Controls:</strong> Zoom, pan, hover for details. This plot streams data as it loads.
        </div>
        <div class="plot-container">
            <div id="plot-7" style="width:100%;height:700px;"></div>
            <div class="loading" id="loading-7"></div>
        </div>
    </div>

    <div id="tab8" class="tab-content">
        <div class="help"><strong>Controls:</strong> Zoom, pan, hover for details. This plot streams data as it loads.
        </div>
        <div class="plot-container">
            <div id="plot-8" style="width:100%;height:700px;"></div>
            <div class="loading" id="loading-8"></div>
        </div>
    </div>

    <div id="tab9" class="tab-content">
        <div class="help"><strong>Controls:</strong> Zoom, pan, hover for details. This plot streams data as it loads.
        </div>
        <div class="plot-container">
            <div id="plot-9" style="width:100%;height:700px;"></div>
            <div class="loading" id="loading-9"></div>
        </div>
    </div>

    <div id="tab10" class="tab-content">
        <div class="help"><strong>Controls:</strong> Zoom, pan, hover for details. Compactness is GM/(Rc²), a
            dimensionless measure of gravitational strength.
        </div>
        <div class="plot-container">
            <div id="plot-10" style="width:100%;height:700px;"></div>
            <div class="loading" id="loading-10"></div>
        </div>
    </div>

    <div id="tab11" class="tab-content">
        <div class="help"><strong>Controls:</strong> Zoom, pan, hover for details. This plot shows how compactness
            relates to rotation.
        </div>
        <div class="plot-container">
            <div id="plot-11" style="width:100%;height:700px;"></div>
            <div class="loading" id="loading-11"></div>
        </div>
    </div>

    <div id="tab12" class="tab-content">
        <div class="help"><strong>Age Groups:</strong> Mass vs Radius with different age groups shown as separate
            traces. This clearly reveals how younger neutron stars follow a different mass-radius relationship than
            older ones.
        </div>
        <div class="plot-container">
            <div id="plot-12" style="width:100%;height:700px;"></div>
            <div class="loading" id="loading-12b"></div>
        </div>
    </div>

    <div id="tab13" class="tab-content">
        <div class="help"><strong>Tangential Velocity vs Compactness:</strong> Shows how tangential velocity (surface
            rotation speed) relates to compactness (mass-to-radius ratio). Color-coded by spin state: green=spin-up
            (recycled pulsars), red=spin-down (magnetic braking), orange=unknown. Click legend to toggle traces.
        </div>
        <div class="plot-container">
            <div id="plot-13" style="width:100%;height:700px;"></div>
            <div class="loading" id="loading-13"></div>
        </div>
    </div>

    <div id="tab14" class="tab-content">
        <div class="help"><strong>Age by Region:</strong> Stacked bar chart showing the distribution of neutron star
            ages across galactic regions. Each bar represents a region with age groups stacked from youngest (bottom) to
            oldest (top).
        </div>
        <div class="plot-container">
            <div id="plot-14" style="width:100%;height:700px;"></div>
            <div class="loading" id="loading-14"></div>
        </div>
    </div>

    <div id="tab15" class="tab-content">
        <div class="help"><strong>Average Age by Region:</strong> Interactive galactic region map and bar chart showing
            the average age of neutron stars in each region. Click regions on the map for details.
        </div>
        <div class="plot-container">
            <div id="region-map-svg" style="width:100%;overflow:hidden;border-radius:8px;"></div>
        </div>
        <div class="plot-container">
            <div id="plot-15" style="width:100%;height:700px;"></div>
            <div class="loading" id="loading-15"></div>
        </div>
    </div>

    <div id="tab16" class="tab-content">
        <div class="help"><strong>Distributions:</strong> Histograms showing the distribution of various neutron star
            parameters.
        </div>
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px;">
            <div class="plot-container">
                <div id="hist-radius" style="width:100%;height:400px;"></div>
            </div>
            <div class="plot-container">
                <div id="hist-period" style="width:100%;height:400px;"></div>
            </div>
            <div class="plot-container">
                <div id="hist-age" style="width:100%;height:400px;"></div>
            </div>
            <div class="plot-container">
                <div id="hist-mass" style="width:100%;height:400px;"></div>
            </div>
            <div class="plot-container">
                <div id="hist-temperature" style="width:100%;height:400px;"></div>
            </div>
            <div class="plot-container">
                <div id="hist-velocity" style="width:100%;height:400px;"></div>
            </div>
            <div class="plot-container">
                <div id="hist-spin" style="width:100%;height:400px;"></div>
            </div>
        </div>
        <div class="loading" id="loading-16"></div>
    </div>

    <script>
        const REGION_MAP_PATH = 'EliteDangerousRegionMap/RegionMapData.json';
        const INITIAL_CHUNK_SIZE = 50000;
        const CHUNK_SIZE = 100000;
        const BATCH_INTERVAL = 500; // Update every 500ms for more visible progress
        const UPDATE_BATCH_SIZE = 50000; // Optimized: Larger batches = fewer updates

        let dataWorker = null;
        let regionMapData = null;
        let regionMap = {}; // id -> name mapping

        const plots = [
            { x: 'solarRadius', y: 'rotationalPeriod', color: 'age', title: 'Radius vs Rotational Period (color=age)', xlabel: 'Radius (km)', ylabel: 'Rotational Period', colorbar: 'Age', colorscale: 'viridis' },
            { x: 'age', y: 'rotationalPeriod', color: 'solarRadius', title: 'Rotational Period vs Age (color=radius)', xlabel: 'Age', ylabel: 'Rotational Period', colorbar: 'Radius (km)', colorscale: 'plasma' },
            { x: 'age', y: 'solarRadius', color: 'rotationalPeriod', title: 'Radius vs Age (color=rotational period)', xlabel: 'Age', ylabel: 'Radius (km)', colorbar: 'Rotational Period', colorscale: 'viridis' },
            { x: 'age', y: 'tangentialVelocity', color: 'mass', title: 'Tangential Velocity vs Age (color=mass)', xlabel: 'Age', ylabel: 'Tangential Velocity (km/s)', colorbar: 'Mass (M☉)', colorscale: 'plasma', reference_line: 299792 },
            { x: 'age', y: 'temperature', color: 'solarRadius', title: 'Temperature vs Age (color=radius)', xlabel: 'Age', ylabel: 'Temperature (K)', colorbar: 'Radius (km)', colorscale: 'plasma' },
            { x: 'mass', y: 'solarRadius', color: 'age', title: 'Radius vs Mass (color=age)', xlabel: 'Mass (M☉)', ylabel: 'Radius (km)', colorbar: 'Age (Myr)', colorscale: 'viridis' },
            { x: 'rotationalPeriod', y: 'periodDerivative', color: 'spin', title: 'P-Ṗ Diagram (color=spin)', xlabel: 'Period P (days)', ylabel: 'Period Derivative Ṗ (s/s)', colorbar: 'Spin State', colorscale: 'viridis', ppdot: true, spinTraces: true },
            { x: 'mass', y: 'rotationalPeriod', color: 'age', title: 'Rotational Period vs Mass (color=age)', xlabel: 'Mass (M☉)', ylabel: 'Rotational Period (days)', colorbar: 'Age (Myr)', colorscale: 'viridis' },
            { x: 'age', y: 'mass', color: 'temperature', title: 'Mass vs Age (color=temperature)', xlabel: 'Age (Myr)', ylabel: 'Mass (M☉)', colorbar: 'Temperature (K)', colorscale: 'viridis' },
            { x: 'mass', y: 'tangentialVelocity', color: 'age', title: 'Tangential Velocity vs Mass (color=age)', xlabel: 'Mass (M☉)', ylabel: 'Tangential Velocity (km/s)', colorbar: 'Age (Myr)', colorscale: 'viridis', reference_line: 299792 },
            { x: 'compactness', y: 'temperature', color: 'age', title: 'Temperature vs Compactness (color=age)', xlabel: 'Compactness (GM/Rc²)', ylabel: 'Surface Temperature (K)', colorbar: 'Age (Myr)', colorscale: 'viridis' },
            { x: 'compactness', y: 'rotationalPeriod', color: 'age', title: 'Rotational Period vs Compactness (color=age)', xlabel: 'Compactness (GM/Rc²)', ylabel: 'Rotational Period (days)', colorbar: 'Age (Myr)', colorscale: 'viridis' },
            { x: 'tangentialVelocity', y: 'compactness', color: 'spin', title: 'Tangential Velocity vs Compactness (color=spin)', xlabel: 'Tangential Velocity (km/s)', ylabel: 'Compactness (GM/Rc²)', colorbar: 'Spin State', colorscale: 'viridis', spinTraces: true, reference_line: 299792 }
        ];

        let csvData = [];
        let csvHeaders = null;
        let csvComplete = false;
        let loadedTabs = new Set();
        let workerMessageId = 0;
        let workerCallbacks = new Map();

        // Format hover text with proper units
        function formatHoverText(row) {
            const SPEED_OF_LIGHT = 299792; // km/s
            const radiusKm = row.solarRadius * 696000;

            let hoverParts = [`<b>${row.system}</b>`];

            // Radius: show both km and solar radius
            if (row.solarRadius !== undefined) {
                hoverParts.push(`Radius: ${radiusKm.toLocaleString(undefined, { maximumFractionDigits: 0 })} km (${row.solarRadius.toFixed(3)} R☉)`);
            }

            // Rotational Period: show in km/s or c
            if (row.rotationalPeriod !== undefined && row.tangentialVelocity !== undefined) {
                if (row.tangentialVelocity >= 0.1 * SPEED_OF_LIGHT) {
                    const speedInC = row.tangentialVelocity / SPEED_OF_LIGHT;
                    hoverParts.push(`Rotational Velocity: ${speedInC.toFixed(3)}c`);
                } else {
                    hoverParts.push(`Rotational Velocity: ${row.tangentialVelocity.toLocaleString(undefined, { maximumFractionDigits: 1 })} km/s`);
                }

                // Format rotational period with appropriate unit
                const periodDays = row.rotationalPeriod;
                const periodSeconds = periodDays * 86400;

                if (periodSeconds < 1) {
                    // Less than 1 second - show in milliseconds
                    hoverParts.push(`Rotational Period: ${(periodSeconds * 1000).toFixed(2)} ms`);
                } else if (periodSeconds < 60) {
                    // Less than 1 minute - show in seconds
                    hoverParts.push(`Rotational Period: ${periodSeconds.toFixed(3)} s`);
                } else if (periodSeconds < 3600) {
                    // Less than 1 hour - show in minutes
                    hoverParts.push(`Rotational Period: ${(periodSeconds / 60).toFixed(2)} min`);
                } else if (periodDays < 1) {
                    // Less than 1 day - show in hours
                    hoverParts.push(`Rotational Period: ${(periodSeconds / 3600).toFixed(2)} hr`);
                } else if (periodDays < 365.25) {
                    // Less than 1 year - show in days
                    hoverParts.push(`Rotational Period: ${periodDays.toFixed(2)} days`);
                } else if (periodDays < 36525) {
                    // Less than 100 years - show in years
                    const periodYears = periodDays / 365.25;
                    hoverParts.push(`Rotational Period: ${periodYears.toFixed(2)} years`);
                } else {
                    // 100 years or more - show in centuries
                    const periodCenturies = periodDays / 36525;
                    hoverParts.push(`Rotational Period: ${periodCenturies.toFixed(2)} centuries`);
                }
            }

            // Age in millions of years (already stored as Myr in CSV)
            if (row.age !== undefined) {
                const ageMyr = row.age;
                if (ageMyr >= 1000) {
                    // Show in billions of years for large values
                    const ageGyr = ageMyr / 1000;
                    hoverParts.push(`Age: ${ageGyr.toLocaleString(undefined, { maximumFractionDigits: 2 })} Gyr`);
                } else {
                    hoverParts.push(`Age: ${ageMyr.toLocaleString(undefined, { maximumFractionDigits: 1 })} Myr`);
                }
            }

            // Temperature in Kelvin
            if (row.temperature !== undefined) {
                hoverParts.push(`Temperature: ${row.temperature.toLocaleString(undefined, { maximumFractionDigits: 0 })} K`);
            }

            // Mass in solar masses
            if (row.mass !== undefined) {
                hoverParts.push(`Mass: ${row.mass.toFixed(3)} M☉`);
            }

            // Spin state
            if (row.spin !== undefined) {
                hoverParts.push(`Spin: ${row.spin}`);
            }

            return hoverParts.join('<br>');
        }

        // Web Worker for data processing
        function createDataWorker() {
            const workerCode = `
                // Format hover text with proper units (inside worker for speed)
                function formatHoverText(row) {
                    const SPEED_OF_LIGHT = 299792; // km/s
                    
                    let hoverParts = ['<b>' + row.system + '</b>'];
                    
                    // Radius: show only in km (already converted)
                    if (row.solarRadius !== undefined) {
                        hoverParts.push('Radius: ' + row.solarRadius.toFixed(0) + ' km');
                    }
                    
                    // Rotational Period: show in km/s or c
                    if (row.rotationalPeriod !== undefined && row.tangentialVelocity !== undefined) {
                        if (row.tangentialVelocity >= 0.1 * SPEED_OF_LIGHT) {
                            const speedInC = row.tangentialVelocity / SPEED_OF_LIGHT;
                            hoverParts.push('Rotational Velocity: ' + speedInC.toFixed(3) + 'c');
                        } else {
                            hoverParts.push('Rotational Velocity: ' + row.tangentialVelocity.toFixed(1) + ' km/s');
                        }
                        
                        // Format rotational period with appropriate unit
                        const periodDays = row.rotationalPeriod;
                        const periodSeconds = periodDays * 86400;
                        
                        if (periodSeconds < 1) {
                            hoverParts.push('Rotational Period: ' + (periodSeconds * 1000).toFixed(2) + ' ms');
                        } else if (periodSeconds < 60) {
                            hoverParts.push('Rotational Period: ' + periodSeconds.toFixed(3) + ' s');
                        } else if (periodSeconds < 3600) {
                            hoverParts.push('Rotational Period: ' + (periodSeconds / 60).toFixed(2) + ' min');
                        } else if (periodDays < 1) {
                            hoverParts.push('Rotational Period: ' + (periodSeconds / 3600).toFixed(2) + ' hr');
                        } else if (periodDays < 365.25) {
                            hoverParts.push('Rotational Period: ' + periodDays.toFixed(2) + ' days');
                        } else if (periodDays < 36525) {
                            const periodYears = periodDays / 365.25;
                            hoverParts.push('Rotational Period: ' + periodYears.toFixed(2) + ' years');
                        } else {
                            const periodCenturies = periodDays / 36525;
                            hoverParts.push('Rotational Period: ' + periodCenturies.toFixed(2) + ' centuries');
                        }
                    }
                    
                    // Age in millions of years
                    if (row.age !== undefined) {
                        const ageMyr = row.age;
                        if (ageMyr >= 1000) {
                            const ageGyr = ageMyr / 1000;
                            hoverParts.push('Age: ' + ageGyr.toFixed(2) + ' Gyr');
                        } else {
                            hoverParts.push('Age: ' + ageMyr.toFixed(1) + ' Myr');
                        }
                    }
                    
                    // Temperature in Kelvin
                    if (row.temperature !== undefined) {
                        hoverParts.push('Temperature: ' + row.temperature.toFixed(0) + ' K');
                    }
                    
                    // Mass in solar masses
                    if (row.mass !== undefined) {
                        hoverParts.push('Mass: ' + row.mass.toFixed(3) + ' M☉');
                    }
                    
                    // Spin state
                    if (row.spin !== undefined) {
                        hoverParts.push('Spin: ' + row.spin);
                    }
                    
                    return hoverParts.join('<br>');
                }
            
                self.onmessage = function(e) {
                    const { type, data, fields, id } = e.data;
                    
                    if (type === 'process') {
                        const processed = data.map(row => {
                            const radiusKm = row.solarRadius * 696000;
                            const periodSeconds = row.rotationalPeriod * 86400;
                            const tangVel = (2 * Math.PI * radiusKm) / periodSeconds;
                            
                            // Calculate period derivative: P-dot = P / (2 * tau)
                            // age is in Myr, convert to seconds: age * 1e6 * 365.25 * 86400
                            const ageSeconds = row.age * 1e6 * 365.25 * 86400;
                            const periodDerivative = periodSeconds / (2 * ageSeconds);
                            
                            // Calculate compactness: GM/(Rc²)
                            // G = 6.67430e-11 m³ kg⁻¹ s⁻²
                            // M_sun = 1.98847e30 kg
                            // R_sun = 6.957e8 m
                            // c = 2.99792458e8 m/s
                            let compactness = null;
                            if (row.mass !== null && row.mass !== undefined) {
                                const G = 6.67430e-11;
                                const M_sun = 1.98847e30;
                                const R_sun = 6.957e8;
                                const c = 2.99792458e8;
                                const M_kg = row.mass * M_sun;
                                const R_m = row.solarRadius * R_sun;
                                compactness = (G * M_kg) / (R_m * c * c);
                            }
                            
                            return {
                                ...row,
                                solarRadius: radiusKm,  // Convert to km
                                tangentialVelocity: tangVel,
                                periodDerivative: periodDerivative,
                                compactness: compactness
                            };
                        });
                        
                        // Return full processed rows with pre-computed hover text
                        self.postMessage({ type: 'processed', data: processed, id: id });
                    }
                };
            `;

            const blob = new Blob([workerCode], { type: 'application/javascript' });
            const worker = new Worker(URL.createObjectURL(blob));

            // Set up single message handler that routes to callbacks
            worker.onmessage = (e) => {
                const { id, type, data } = e.data;
                if (type === 'processed' && workerCallbacks.has(id)) {
                    workerCallbacks.get(id)(data);
                    workerCallbacks.delete(id);
                }
            };

            return worker;
        }

        // Helper to process data with worker
        function processWithWorker(data, fields) {
            return new Promise((resolve) => {
                const id = workerMessageId++;
                workerCallbacks.set(id, resolve);
                dataWorker.postMessage({
                    type: 'process',
                    data: data,
                    fields: fields,
                    id: id
                });
            });
        }

        // Format hover text for a single row
        function formatHoverTextForRow(row) {
            const SPEED_OF_LIGHT = 299792;
            const radiusKm = row.solarRadius;
            let hoverParts = [`<b>${row.system}</b>`];
            if (row.solarRadius !== undefined) {
                hoverParts.push(`Radius: ${radiusKm.toLocaleString(undefined, { maximumFractionDigits: 0 })} km`);
            }
            if (row.rotationalPeriod !== undefined && row.tangentialVelocity !== undefined) {
                if (row.tangentialVelocity >= 0.1 * SPEED_OF_LIGHT) {
                    const speedInC = row.tangentialVelocity / SPEED_OF_LIGHT;
                    hoverParts.push(`Rotational Velocity: ${speedInC.toFixed(3)}c`);
                } else {
                    hoverParts.push(`Rotational Velocity: ${row.tangentialVelocity.toLocaleString(undefined, { maximumFractionDigits: 1 })} km/s`);
                }
                const periodDays = row.rotationalPeriod;
                const periodSeconds = periodDays * 86400;
                if (periodSeconds < 1) {
                    hoverParts.push(`Rotational Period: ${(periodSeconds * 1000).toFixed(2)} ms`);
                } else if (periodSeconds < 60) {
                    hoverParts.push(`Rotational Period: ${periodSeconds.toFixed(3)} s`);
                } else if (periodSeconds < 3600) {
                    hoverParts.push(`Rotational Period: ${(periodSeconds / 60).toFixed(2)} min`);
                } else if (periodDays < 1) {
                    hoverParts.push(`Rotational Period: ${(periodSeconds / 3600).toFixed(2)} hr`);
                } else if (periodDays < 365.25) {
                    hoverParts.push(`Rotational Period: ${periodDays.toFixed(2)} days`);
                } else {
                    hoverParts.push(`Rotational Period: ${(periodDays / 365.25).toFixed(2)} yr`);
                }
            }
            if (row.age !== undefined) {
                const ageMyr = row.age;
                const ageGyr = ageMyr / 1000;
                if (ageGyr >= 1) {
                    hoverParts.push(`Age: ${ageGyr.toLocaleString(undefined, { maximumFractionDigits: 2 })} Gyr`);
                } else {
                    hoverParts.push(`Age: ${ageMyr.toLocaleString(undefined, { maximumFractionDigits: 1 })} Myr`);
                }
            }
            if (row.temperature !== undefined) {
                hoverParts.push(`Temperature: ${row.temperature.toLocaleString(undefined, { maximumFractionDigits: 0 })} K`);
            }
            if (row.mass !== undefined) {
                hoverParts.push(`Mass: ${row.mass.toFixed(2)} M☉`);
            }
            if (row.compactness !== undefined && row.compactness !== null) {
                hoverParts.push(`Compactness: ${row.compactness.toExponential(3)}`);
            }
            if (row.spin !== undefined) {
                hoverParts.push(`Spin: ${row.spin}`);
            }
            return hoverParts.join('<br>');
        }

        // Smart downsampling: reduce overlapping points at default zoom
        function downsampleForDisplay(rows, xField, yField, colorField, gridSize = 800) {
            if (rows.length === 0) return rows;

            // Filter out rows with invalid x or y values first
            const validRows = rows.filter(row => {
                const x = row[xField];
                const y = row[yField];
                return x !== null && x !== undefined && y !== null && y !== undefined &&
                    isFinite(x) && isFinite(y);
            });

            if (validRows.length === 0) {
                console.log('[Downsample] No valid points for downsampling');
                return [];
            }

            // Find data ranges (handle both linear and log axes)
            let xMin = Infinity, xMax = -Infinity;
            let yMin = Infinity, yMax = -Infinity;

            // Check if fields should use log scale
            const useLogX = !(xField === 'age' || xField === 'mass' || xField === 'solarRadius' || xField === 'temperature' || xField === 'compactness');
            const useLogY = !(yField === 'age' || yField === 'mass' || yField === 'solarRadius' || yField === 'temperature' || yField === 'compactness');

            for (const row of validRows) {
                const x = row[xField];
                const y = row[yField];

                const xVal = (useLogX && x > 0) ? Math.log10(x) : x;
                const yVal = (useLogY && y > 0) ? Math.log10(y) : y;

                if (isFinite(xVal) && isFinite(yVal)) {
                    if (xVal < xMin) xMin = xVal;
                    if (xVal > xMax) xMax = xVal;
                    if (yVal < yMin) yMin = yVal;
                    if (yVal > yMax) yMax = yVal;
                }
            }

            // If ranges are invalid, return valid rows
            if (!isFinite(xMin) || !isFinite(xMax) || !isFinite(yMin) || !isFinite(yMax)) {
                console.log('[Downsample] Invalid ranges, returning valid rows');
                return validRows;
            }

            // Create spatial grid
            const grid = new Map();
            const xRange = xMax - xMin;
            const yRange = yMax - yMin;

            // Safety check for range
            if (xRange === 0 || yRange === 0) {
                console.log('[Downsample] Zero range detected, returning valid rows');
                return validRows;
            }

            // Bin points into grid cells (store arrays of points per cell)
            for (const row of validRows) {
                const x = row[xField];
                const y = row[yField];

                const xVal = (useLogX && x > 0) ? Math.log10(x) : x;
                const yVal = (useLogY && y > 0) ? Math.log10(y) : y;

                if (isFinite(xVal) && isFinite(yVal)) {
                    // Calculate grid cell
                    const cellX = Math.floor((xVal - xMin) / xRange * gridSize);
                    const cellY = Math.floor((yVal - yMin) / yRange * gridSize);
                    const cellKey = cellX + ',' + cellY;

                    // Store all points in this cell
                    if (!grid.has(cellKey)) {
                        grid.set(cellKey, []);
                    }
                    grid.get(cellKey).push(row);
                }
            }

            // Select representative points from each cell
            // Keep 1 point per cell, or more if there's significant color variation
            const sampled = [];

            for (const cellPoints of grid.values()) {
                if (cellPoints.length === 1) {
                    sampled.push(cellPoints[0]);
                    continue;
                }

                // For cells with multiple points, check color variation
                const pointsWithColor = cellPoints.filter(p => p[colorField] !== undefined && isFinite(p[colorField]));

                if (pointsWithColor.length === 0) {
                    sampled.push(cellPoints[0]);
                    continue;
                }

                // Sort by color value
                pointsWithColor.sort((a, b) => a[colorField] - b[colorField]);

                const minColor = pointsWithColor[0][colorField];
                const maxColor = pointsWithColor[pointsWithColor.length - 1][colorField];
                const colorRange = maxColor - minColor;
                const avgColor = (minColor + maxColor) / 2;

                // If color variation is significant (>20% of average), keep min/mid/max
                // Otherwise just keep one representative
                if (colorRange > avgColor * 0.2 && pointsWithColor.length >= 3) {
                    // Keep 3 points showing color range
                    sampled.push(pointsWithColor[0]); // min
                    sampled.push(pointsWithColor[Math.floor(pointsWithColor.length / 2)]); // mid
                    sampled.push(pointsWithColor[pointsWithColor.length - 1]); // max
                } else {
                    // Keep just one point (median)
                    sampled.push(pointsWithColor[Math.floor(pointsWithColor.length / 2)]);
                }
            }

            // Safety check: if downsampling removed too many points, return original
            if (sampled.length === 0) {
                console.log('[Downsample] Result was empty, returning original');
                return rows;
            }

            // Compute hoverText only for downsampled points
            const SPEED_OF_LIGHT = 299792;
            sampled.forEach(row => {
                const radiusKm = row.solarRadius;
                let hoverParts = [];

                // Show body name (or system if body not available)
                if (row.body) {
                    hoverParts.push(`<b>${row.body}</b>`);
                } else if (row.system) {
                    hoverParts.push(`<b>${row.system}</b>`);
                }

                // Show region if available
                if (row.region) {
                    hoverParts.push(`Region: ${row.region}`);
                }

                // Show system name if we showed body name
                if (row.body && row.system) {
                    hoverParts.push(`System: ${row.system}`);
                }

                if (row.solarRadius !== undefined && row.solarRadius !== null) {
                    hoverParts.push(`Radius: ${radiusKm.toLocaleString(undefined, { maximumFractionDigits: 0 })} km`);
                }

                if (row.rotationalPeriod !== undefined && row.rotationalPeriod !== null && row.tangentialVelocity !== undefined && row.tangentialVelocity !== null) {
                    if (row.tangentialVelocity >= 0.1 * SPEED_OF_LIGHT) {
                        const speedInC = row.tangentialVelocity / SPEED_OF_LIGHT;
                        hoverParts.push(`Rotational Velocity: ${speedInC.toFixed(3)}c`);
                    } else {
                        hoverParts.push(`Rotational Velocity: ${row.tangentialVelocity.toLocaleString(undefined, { maximumFractionDigits: 1 })} km/s`);
                    }

                    const periodDays = row.rotationalPeriod;
                    const periodSeconds = periodDays * 86400;
                    if (periodSeconds < 1) {
                        hoverParts.push(`Rotational Period: ${(periodSeconds * 1000).toFixed(2)} ms`);
                    } else if (periodSeconds < 60) {
                        hoverParts.push(`Rotational Period: ${periodSeconds.toFixed(3)} s`);
                    } else if (periodSeconds < 3600) {
                        hoverParts.push(`Rotational Period: ${(periodSeconds / 60).toFixed(2)} min`);
                    } else if (periodDays < 1) {
                        hoverParts.push(`Rotational Period: ${(periodSeconds / 3600).toFixed(2)} hr`);
                    } else if (periodDays < 365.25) {
                        hoverParts.push(`Rotational Period: ${periodDays.toFixed(2)} days`);
                    } else {
                        hoverParts.push(`Rotational Period: ${(periodDays / 365.25).toFixed(2)} yr`);
                    }
                }

                if (row.age !== undefined && row.age !== null) {
                    const ageMyr = row.age;
                    const ageGyr = ageMyr / 1000;
                    if (ageGyr >= 1) {
                        hoverParts.push(`Age: ${ageGyr.toLocaleString(undefined, { maximumFractionDigits: 2 })} Gyr`);
                    } else {
                        hoverParts.push(`Age: ${ageMyr.toLocaleString(undefined, { maximumFractionDigits: 1 })} Myr`);
                    }
                }

                if (row.temperature !== undefined && row.temperature !== null) {
                    hoverParts.push(`Temperature: ${row.temperature.toLocaleString(undefined, { maximumFractionDigits: 0 })} K`);
                }

                if (row.mass !== undefined && row.mass !== null) {
                    hoverParts.push(`Mass: ${row.mass.toFixed(2)} M☉`);
                }

                if (row.compactness !== undefined && row.compactness !== null) {
                    hoverParts.push(`Compactness: ${row.compactness.toExponential(3)}`);
                }

                if (row.spin !== undefined && row.spin !== null) {
                    hoverParts.push(`Spin: ${row.spin}`);
                }

                row.hoverText = hoverParts.join('<br>');
            });

            console.log('[Downsample] Reduced ' + rows.length.toLocaleString() + ' → ' + sampled.length.toLocaleString() + ' points (' + (sampled.length / rows.length * 100).toFixed(1) + '%)');
            return sampled;
        }

        function parseCSVLine(line, headers) {
            const values = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    values.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            values.push(current.trim());

            const row = {};
            headers.forEach((h, i) => {
                const val = values[i];
                if (h && val !== undefined && val !== '') {
                    row[h] = isNaN(val) ? val : parseFloat(val);
                }
            });

            return row;
        }

        let progressCallbacks = [];
        let csvLoading = false;
        let csvLoadPromise = null;

        // Load region map data
        async function loadRegionMap() {
            if (regionMapData) return regionMapData;

            try {
                const response = await fetch(REGION_MAP_PATH);
                regionMapData = await response.json();

                // The regions array is indexed by region ID
                if (regionMapData.regions && Array.isArray(regionMapData.regions)) {
                    console.log('[RegionMap] Regions array length:', regionMapData.regions.length);
                    for (let i = 0; i < regionMapData.regions.length; i++) {
                        const region = regionMapData.regions[i];
                        if (region) {
                            regionMap[i] = region;
                            console.log('[RegionMap] Index', i, '=', region);
                        } else {
                            console.log('[RegionMap] Index', i, '= (null or no name)');
                        }
                    }
                }

                console.log('[RegionMap] Loaded ' + Object.keys(regionMap).length + ' region names');
                return regionMapData;
            } catch (error) {
                console.error('[RegionMap] Error loading:', error);
                return null;
            }
        }

        async function loadCSVStreaming(onProgress) {
            // If already complete, return immediately
            if (csvComplete && csvData.length > 0) {
                if (onProgress) onProgress(csvData.length, true, null);
                return csvData;
            }

            // If currently loading, wait for existing load to complete
            if (csvLoading && csvLoadPromise) {
                console.log('[CSV] Already loading, waiting for completion...');
                if (onProgress) {
                    progressCallbacks.push(onProgress);
                }
                return csvLoadPromise;
            }

            // Start new load
            csvLoading = true;

            // Load region map first
            await loadRegionMap();

            console.log('[CSV] Loading region files...');

            csvLoadPromise = (async () => {
                try {
                    let filesLoaded = 0;
                    let filesSkipped = 0;

                    // Load each region file (regions 1-42)
                    for (let regionId = 1; regionId <= 42; regionId++) {
                        const regionName = regionMap[regionId] || 'Region ' + regionId;
                        const paddedId = regionId.toString().padStart(2, '0');
                        const filePath = 'Region_' + paddedId + '.csv.gz';

                        console.log('[CSV] Region ID', regionId, '-> Name:', regionName, '(from regionMap[' + regionId + '])');
                        console.log('[CSV] Attempting to load ' + filePath + ' (' + regionName + ')');
                        if (onProgress) onProgress(csvData.length, false, regionName);
                        progressCallbacks.forEach(cb => cb(csvData.length, false, regionName));

                        try {
                            const rowsBefore = csvData.length;
                            const response = await fetch(filePath);
                            if (!response.ok) {
                                console.warn('[CSV] File not found (HTTP ' + response.status + '): ' + filePath);
                                filesSkipped++;
                                continue;
                            }

                            const reader = response.body.pipeThrough(new DecompressionStream('gzip')).getReader();
                            const decoder = new TextDecoder();
                            let buffer = '';
                            let headersParsed = false;
                            let fileHeaders = null;

                            while (true) {
                                const { done, value } = await reader.read();
                                if (done) break;

                                buffer += decoder.decode(value, { stream: true });

                                const lines = buffer.split('\n');
                                buffer = lines[lines.length - 1];

                                for (let i = 0; i < lines.length - 1; i++) {
                                    const line = lines[i].trim();
                                    if (!line) continue;

                                    if (!headersParsed) {
                                        fileHeaders = line.split(',').map(h => h.trim().replace(/\r/g, ''));
                                        headersParsed = true;

                                        // Use first file's headers as the global headers
                                        if (!csvHeaders) {
                                            csvHeaders = fileHeaders;
                                            console.log('[CSV] Headers:', csvHeaders);
                                        }
                                    } else {
                                        const row = parseCSVLine(line, fileHeaders);
                                        row.region = regionName; // Add region name to each row
                                        csvData.push(row);
                                    }
                                }
                            }

                            if (buffer.trim() && headersParsed) {
                                const row = parseCSVLine(buffer.trim(), fileHeaders);
                                row.region = regionName; // Add region name to each row
                                csvData.push(row);
                            }

                            const rowsAdded = csvData.length - rowsBefore;
                            console.log('[CSV] ' + regionName + ': added ' + rowsAdded.toLocaleString() + ' rows (total: ' + csvData.length.toLocaleString() + ')');
                            filesLoaded++;

                        } catch (fileError) {
                            console.error('[CSV] Error loading ' + filePath + ':', fileError);
                            filesSkipped++;
                        }
                    }

                    console.log('[CSV] Complete! Loaded ' + filesLoaded + ' files, skipped ' + filesSkipped + ' files. Total rows: ' + csvData.length.toLocaleString());
                    csvComplete = true;
                    csvLoading = false;
                    if (onProgress) onProgress(csvData.length, true, null);
                    progressCallbacks.forEach(cb => cb(csvData.length, true, null));
                    progressCallbacks = [];

                } catch (error) {
                    console.error('[CSV] Loading error:', error);
                    csvLoading = false;
                }

                return csvData;
            })();

            return csvLoadPromise;
        }

        function showTab(index) {
            const tabs = document.querySelectorAll('.tab');
            const contents = document.querySelectorAll('.tab-content');

            tabs.forEach((tab, i) => {
                tab.classList.toggle('active', i === index);
            });

            contents.forEach((content, i) => {
                content.classList.toggle('active', i === index);
            });

            if (!loadedTabs.has(index)) {
                console.log('[Tab ' + index + '] Loading plot...');
                if (index === 12) {
                    loadMassRadiusByAgeGroups(index);
                } else if (index === 14) {
                    loadAgeByRegion(index);
                } else if (index === 15) {
                    loadAverageAgeByRegion(index);
                } else if (index === 16) {
                    loadHistograms(index);
                } else {
                    loadAndStreamData(index);
                }
            } else {
                console.log('[Tab ' + index + '] Already loaded');
                // Ensure loading div shows completion status, not spinner
                const loadingDiv = document.getElementById('loading-' + index);
                if (loadingDiv && loadingDiv.innerHTML.includes('spinner')) {
                    const totalPoints = csvData.length;
                    loadingDiv.innerHTML = '<div style="color: #4a9eff; font-weight: 500;">✓ Loaded ' + totalPoints.toLocaleString() + ' data points</div>';
                }
            }
        }

        async function loadMassRadiusByAgeGroups(tabIndex) {
            const loadingDiv = document.getElementById('loading-12b');
            const plotDiv = document.getElementById('plot-12');
            loadingDiv.innerHTML = '<div class="spinner"></div>Waiting for complete dataset...';

            // Wait a moment for tab to fully render
            await new Promise(resolve => setTimeout(resolve, 100));

            try {
                // Get initial data
                const data = await loadCSVStreaming();
                if (!data) {
                    loadingDiv.innerHTML = '<div style="color: #f44336;">Error loading CSV</div>';
                    return;
                }

                // Wait for CSV to completely load
                while (!csvComplete) {
                    loadingDiv.innerHTML = '<div class="spinner"></div>Loading data... ' + csvData.length.toLocaleString() + ' rows loaded';
                    await new Promise(resolve => setTimeout(resolve, 200));
                }

                loadingDiv.innerHTML = '<div class="spinner"></div>Processing ' + csvData.length.toLocaleString() + ' data points...';

                // Process ALL data at once
                const processedData = await processWithWorker(csvData, null);

                console.log('[Mass-Radius Age Groups] Creating plot with ' + processedData.length + ' total points');

                // Filter to valid mass and radius data
                const validData = processedData.filter(r =>
                    r.mass !== null && r.mass !== undefined && !isNaN(r.mass) &&
                    r.solarRadius !== null && r.solarRadius !== undefined && !isNaN(r.solarRadius) &&
                    r.age !== null && r.age !== undefined && !isNaN(r.age)
                );

                console.log('[Mass-Radius Age Groups] Filtered to ' + validData.length.toLocaleString() + ' valid points');

                // Define age groups (in Myr)
                const ageGroups = [
                    { name: '< 1 Myr (Very Young)', min: 0, max: 1, color: '#ff0000' },
                    { name: '1-10 Myr (Young)', min: 1, max: 10, color: '#ff6b00' },
                    { name: '10-100 Myr', min: 10, max: 100, color: '#ffa500' },
                    { name: '100-1000 Myr', min: 100, max: 1000, color: '#ffff00' },
                    { name: '1-10 Gyr', min: 1000, max: 10000, color: '#00ff00' },
                    { name: '> 10 Gyr (Very Old)', min: 10000, max: Infinity, color: '#0000ff' }
                ];

                // Group data by age
                const traces = [];
                for (const group of ageGroups) {
                    const groupData = validData.filter(r => r.age >= group.min && r.age < group.max);

                    if (groupData.length === 0) {
                        console.log('[Mass-Radius Age Groups] No data for group: ' + group.name);
                        continue;
                    }

                    // Downsample large groups for performance
                    const sampledData = groupData.length > 50000
                        ? downsampleForDisplay(groupData, 'mass', 'solarRadius', 'age', 400)
                        : groupData;

                    console.log('[Mass-Radius Age Groups] Group "' + group.name + '": ' + groupData.length.toLocaleString() + ' points → ' + sampledData.length.toLocaleString() + ' displayed');

                    const massData = [];
                    const radiusData = [];
                    const textData = [];

                    // Build hover text inline like other charts
                    const SPEED_OF_LIGHT = 299792;
                    for (const r of sampledData) {
                        massData.push(r.mass);
                        radiusData.push(r.solarRadius);

                        // Create hover text
                        const radiusKm = r.solarRadius;
                        let hoverParts = [`<b>${r.system}</b>`];

                        if (r.solarRadius !== undefined && r.solarRadius !== null) {
                            hoverParts.push(`Radius: ${radiusKm.toLocaleString(undefined, { maximumFractionDigits: 0 })} km`);
                        }

                        if (r.mass !== undefined && r.mass !== null) {
                            hoverParts.push(`Mass: ${r.mass.toFixed(2)} M☉`);
                        }

                        if (r.age !== undefined && r.age !== null) {
                            const ageMyr = r.age;
                            const ageGyr = ageMyr / 1000;
                            if (ageGyr >= 1) {
                                hoverParts.push(`Age: ${ageGyr.toLocaleString(undefined, { maximumFractionDigits: 2 })} Gyr`);
                            } else {
                                hoverParts.push(`Age: ${ageMyr.toLocaleString(undefined, { maximumFractionDigits: 1 })} Myr`);
                            }
                        }

                        if (r.temperature !== undefined && r.temperature !== null) {
                            hoverParts.push(`Temperature: ${r.temperature.toLocaleString(undefined, { maximumFractionDigits: 0 })} K`);
                        }

                        if (r.compactness !== undefined && r.compactness !== null) {
                            hoverParts.push(`Compactness: ${r.compactness.toExponential(3)}`);
                        }

                        textData.push(hoverParts.join('<br>'));
                    }

                    traces.push({
                        x: massData,
                        y: radiusData,
                        mode: 'markers',
                        type: 'scattergl',
                        name: group.name + ' (' + groupData.length.toLocaleString() + ' stars)',
                        marker: {
                            size: 3,
                            color: group.color,
                            opacity: 0.6
                        },
                        text: textData,
                        hoverinfo: 'text'
                    });
                }

                // Calculate data ranges for physics lines
                let dataXMin = Infinity;
                let dataXMax = -Infinity;
                let dataYMin = Infinity;
                let dataYMax = -Infinity;

                for (const r of validData) {
                    if (r.mass < dataXMin) dataXMin = r.mass;
                    if (r.mass > dataXMax) dataXMax = r.mass;
                    if (r.solarRadius < dataYMin) dataYMin = r.solarRadius;
                    if (r.solarRadius > dataYMax) dataYMax = r.solarRadius;
                }

                const layout = {
                    title: 'Mass vs Radius by Age Groups - Reveals Evolution Curves',
                    xaxis: {
                        title: 'Mass (M☉)',
                        type: 'linear',
                        gridcolor: '#333'
                    },
                    yaxis: {
                        title: 'Radius (km)',
                        type: 'linear',
                        gridcolor: '#333'
                    },
                    paper_bgcolor: '#1a1a1a',
                    plot_bgcolor: '#1a1a1a',
                    font: { color: '#fff' },
                    hovermode: 'closest',
                    autosize: true,
                    height: 700,
                    margin: { l: 80, r: 80, t: 80, b: 80 },
                    showlegend: true,
                    legend: {
                        x: 1.02,
                        y: 1,
                        xanchor: 'left',
                        bgcolor: 'rgba(45, 45, 45, 0.8)',
                        bordercolor: '#555',
                        borderwidth: 1
                    }
                };

                // Add Schwarzschild radius line
                const schwarzschildSlope = 2.95;
                let schwY0 = dataXMin * schwarzschildSlope;
                let schwY1 = dataXMax * schwarzschildSlope;
                let schwX0 = dataXMin;
                let schwX1 = dataXMax;

                if (schwY0 < dataYMin) {
                    schwX0 = dataYMin / schwarzschildSlope;
                    schwY0 = dataYMin;
                }
                if (schwY1 > dataYMax) {
                    schwX1 = dataYMax / schwarzschildSlope;
                    schwY1 = dataYMax;
                }

                layout.shapes = [
                    {
                        type: 'line',
                        x0: schwX0,
                        x1: schwX1,
                        y0: schwY0,
                        y1: schwY1,
                        line: { color: '#ff0000', width: 2.5, dash: 'dot' },
                        layer: 'below'
                    }
                ];

                // Add TOV limit if in range
                if (2.5 >= dataXMin && 2.5 <= dataXMax) {
                    layout.shapes.push({
                        type: 'line',
                        x0: 2.5,
                        x1: 2.5,
                        y0: dataYMin,
                        y1: dataYMax,
                        line: { color: '#9933ff', width: 2.5, dash: 'dot' },
                        layer: 'below'
                    });
                }

                // Add annotations
                layout.annotations = [
                    {
                        x: 0.98,
                        y: 0.98,
                        xref: 'paper',
                        yref: 'paper',
                        text: '⋯⋯⋯ Schwarzschild Radius',
                        showarrow: false,
                        font: { color: '#ff0000', size: 12 },
                        xanchor: 'right',
                        yanchor: 'top',
                        bgcolor: 'rgba(0,0,0,0.7)',
                        borderpad: 4
                    }
                ];

                if (2.5 >= dataXMin && 2.5 <= dataXMax) {
                    layout.annotations.push({
                        x: 0.98,
                        y: 0.92,
                        xref: 'paper',
                        yref: 'paper',
                        text: '⋯⋯⋯ TOV Limit (2.5 M☉)',
                        showarrow: false,
                        font: { color: '#9933ff', size: 12 },
                        xanchor: 'right',
                        yanchor: 'top',
                        bgcolor: 'rgba(0,0,0,0.7)',
                        borderpad: 4
                    });
                }

                // Render the plot
                plotDiv.style.display = 'none';
                loadingDiv.innerHTML = '<div class="spinner"></div>Rendering chart...';
                await new Promise(resolve => requestAnimationFrame(resolve));

                await Plotly.newPlot(plotDiv, traces, layout, {
                    responsive: true,
                    displayModeBar: true
                });

                plotDiv.style.display = 'block';
                Plotly.Plots.resize(plotDiv);

                // Add click handler
                plotDiv.on('plotly_click', function (data) {
                    const point = data.points[0];
                    if (point && point.text) {
                        const systemMatch = point.text.match(/<b>(.*?)<\/b>/);
                        if (systemMatch) {
                            const systemName = systemMatch[1];
                            const url = 'https://signals.canonn.tech/?system=' + encodeURIComponent(systemName);
                            console.log('[Plot] Opening system:', systemName, 'at', url);
                            window.open(url, '_blank');
                        }
                    }
                });

                loadingDiv.innerHTML = '<div style="color: #4a9eff; font-weight: 500;">✓ Loaded ' + validData.length.toLocaleString() + ' data points in ' + traces.length + ' age groups | Click any point to view in Canonn Signals</div>';
                loadedTabs.add(tabIndex);

            } catch (error) {
                console.error('[Mass-Radius Age Groups] Error:', error);
                loadingDiv.innerHTML = '<div style="color: #f44336;">Error loading plot: ' + error.message + '</div>';
            }
        }

        async function loadAgeByRegion(tabIndex) {
            const loadingDiv = document.getElementById('loading-14');
            const plotDiv = document.getElementById('plot-14');
            loadingDiv.innerHTML = '<div class="spinner"></div>Waiting for complete dataset...';

            await new Promise(resolve => setTimeout(resolve, 100));

            try {
                // Get initial data
                const data = await loadCSVStreaming();
                if (!data) {
                    loadingDiv.innerHTML = '<div style="color: #f44336;">Error loading CSV</div>';
                    return;
                }

                // Wait for CSV to completely load
                while (!csvComplete) {
                    loadingDiv.innerHTML = '<div class="spinner"></div>Loading data... ' + csvData.length.toLocaleString() + ' rows loaded';
                    await new Promise(resolve => setTimeout(resolve, 200));
                }

                loadingDiv.innerHTML = '<div class="spinner"></div>Processing ' + csvData.length.toLocaleString() + ' data points by region and age...';

                // Process ALL data at once
                const processedData = await processWithWorker(csvData, null);

                console.log('[Age by Region] Creating stacked bar chart with ' + processedData.length + ' total points');

                // Define age groups (youngest to oldest)
                const ageGroups = [
                    { name: '< 10 Myr (Very Young)', min: 0, max: 10, color: '#1f77b4' },
                    { name: '10-100 Myr (Young)', min: 10, max: 100, color: '#ff7f0e' },
                    { name: '100-1000 Myr', min: 100, max: 1000, color: '#2ca02c' },
                    { name: '1-10 Gyr', min: 1000, max: 10000, color: '#d62728' },
                    { name: '> 10 Gyr (Very Old)', min: 10000, max: Infinity, color: '#9467bd' }
                ];

                // Build region ID to name mapping (already loaded)
                const regions = [];
                for (let i = 0; i < 42; i++) {
                    if (regionMap[i]) {
                        regions.push({ id: i, name: regionMap[i] });
                    }
                }

                // Count stars by region and age group
                const counts = {};
                regions.forEach(region => {
                    counts[region.id] = {};
                    ageGroups.forEach(group => {
                        counts[region.id][group.name] = 0;
                    });
                });

                // Count data points
                processedData.forEach(row => {
                    if (!row.region || row.age === null || row.age === undefined) return;

                    // Find region ID from region name
                    const regionEntry = regions.find(r => r.name === row.region);
                    if (!regionEntry) return;

                    // Find age group
                    const ageGroup = ageGroups.find(g => row.age >= g.min && row.age < g.max);
                    if (!ageGroup) return;

                    counts[regionEntry.id][ageGroup.name]++;
                });

                // Create traces for each age group (stacked)
                const traces = [];

                // First calculate totals per region for percentage calculation
                const regionTotals = {};
                regions.forEach(region => {
                    regionTotals[region.id] = 0;
                    ageGroups.forEach(group => {
                        regionTotals[region.id] += counts[region.id][group.name] || 0;
                    });
                });

                ageGroups.forEach(group => {
                    const xData = [];
                    const yData = [];
                    const textData = [];

                    regions.forEach(region => {
                        const count = counts[region.id][group.name] || 0;
                        const total = regionTotals[region.id];
                        const percentage = total > 0 ? (count / total * 100) : 0;

                        xData.push(region.name);
                        yData.push(percentage);
                        textData.push(count.toLocaleString() + ' stars (' + percentage.toFixed(1) + '%)');
                    });

                    traces.push({
                        x: xData,
                        y: yData,
                        name: group.name,
                        type: 'bar',
                        marker: { color: group.color },
                        text: textData,
                        hovertemplate: '%{x}<br>%{fullData.name}<br>%{text}<extra></extra>'
                    });
                });

                const layout = {
                    title: 'Neutron Star Age Distribution by Galactic Region',
                    barmode: 'stack',
                    xaxis: {
                        title: 'Galactic Region',
                        tickangle: -45,
                        automargin: true
                    },
                    yaxis: {
                        title: 'Percentage (%)',
                        gridcolor: '#333',
                        range: [0, 100]
                    },
                    paper_bgcolor: '#1a1a1a',
                    plot_bgcolor: '#1a1a1a',
                    font: { color: '#fff' },
                    autosize: true,
                    height: 700,
                    margin: { l: 80, r: 80, t: 80, b: 150 },
                    showlegend: true,
                    legend: {
                        x: 1.02,
                        y: 1,
                        xanchor: 'left',
                        bgcolor: 'rgba(45, 45, 45, 0.9)',
                        bordercolor: '#555',
                        borderwidth: 1
                    }
                };

                plotDiv.style.display = 'none';
                loadingDiv.innerHTML = '<div class="spinner"></div>Rendering chart...';
                await new Promise(resolve => requestAnimationFrame(resolve));

                await Plotly.newPlot(plotDiv, traces, layout, {
                    responsive: true,
                    displayModeBar: true
                });

                plotDiv.style.display = 'block';
                Plotly.Plots.resize(plotDiv);

                loadingDiv.innerHTML = '<div style="color: #4a9eff; font-weight: 500;">✓ Loaded age distribution across ' + regions.length + ' regions with ' + processedData.length.toLocaleString() + ' neutron stars</div>';
                loadedTabs.add(tabIndex);

            } catch (error) {
                console.error('[Age by Region] Error:', error);
                loadingDiv.innerHTML = '<div style="color: #f44336;">Error loading plot: ' + error.message + '</div>';
            }
        }

        async function loadAverageAgeByRegion(tabIndex) {
            const loadingDiv = document.getElementById('loading-15');
            const plotDiv = document.getElementById('plot-15');
            loadingDiv.innerHTML = '<div class="spinner"></div>Waiting for complete dataset...';

            await new Promise(resolve => setTimeout(resolve, 100));

            try {
                // Get initial data
                const data = await loadCSVStreaming();
                if (!data) {
                    loadingDiv.innerHTML = '<div style="color: #f44336;">Error loading CSV</div>';
                    return;
                }

                // Wait for CSV to completely load
                while (!csvComplete) {
                    loadingDiv.innerHTML = '<div class="spinner"></div>Loading data... ' + csvData.length.toLocaleString() + ' rows loaded';
                    await new Promise(resolve => setTimeout(resolve, 200));
                }

                loadingDiv.innerHTML = '<div class="spinner"></div>Calculating average ages by region...';

                // Process ALL data at once
                const processedData = await processWithWorker(csvData, null);

                console.log('[Average Age by Region] Creating bar chart with ' + processedData.length + ' total points');

                // Build region ID to name mapping
                const regions = [];
                for (let i = 1; i <= 42; i++) {
                    if (regionMap[i]) {
                        regions.push({ id: i, name: regionMap[i] });
                    }
                }

                // Calculate average age per region
                const regionStats = {};
                regions.forEach(region => {
                    regionStats[region.id] = { sum: 0, count: 0 };
                });

                // Sum ages and count stars per region
                processedData.forEach(row => {
                    if (!row.region || row.age === null || row.age === undefined) return;

                    // Find region ID from region name
                    const regionEntry = regions.find(r => r.name === row.region);
                    if (!regionEntry) return;

                    regionStats[regionEntry.id].sum += row.age;
                    regionStats[regionEntry.id].count++;
                });

                // Calculate averages
                const xData = [];
                const yData = [];
                const textData = [];

                regions.forEach(region => {
                    const stats = regionStats[region.id];
                    const avgAge = stats.count > 0 ? stats.sum / stats.count : 0;

                    xData.push(region.name);
                    yData.push(avgAge);
                    textData.push(avgAge.toFixed(1) + ' Myr (' + stats.count.toLocaleString() + ' stars)');
                });

                const trace = {
                    x: xData,
                    y: yData,
                    type: 'bar',
                    marker: {
                        color: yData,
                        colorscale: 'Viridis',
                        showscale: true,
                        colorbar: {
                            title: 'Avg Age (Myr)',
                            titlefont: { color: '#fff' },
                            tickfont: { color: '#fff' }
                        }
                    },
                    text: textData,
                    hovertemplate: '%{x}<br>Average Age: %{text}<extra></extra>'
                };

                const layout = {
                    title: 'Average Neutron Star Age by Galactic Region',
                    xaxis: {
                        title: 'Galactic Region',
                        tickangle: -45,
                        automargin: true,
                        gridcolor: '#333'
                    },
                    yaxis: {
                        title: 'Average Age (Myr)',
                        gridcolor: '#333'
                    },
                    paper_bgcolor: '#1a1a1a',
                    plot_bgcolor: '#1a1a1a',
                    font: { color: '#fff' },
                    autosize: true,
                    height: 700,
                    margin: { l: 80, r: 80, t: 80, b: 150 },
                    showlegend: false
                };

                // Load and color the SVG map
                loadingDiv.innerHTML = '<div class="spinner"></div>Loading region map...';
                const svgContainer = document.getElementById('region-map-svg');

                try {
                    const svgResponse = await fetch('EliteDangerousRegionMap/RegionMap.svg');
                    if (!svgResponse.ok) {
                        throw new Error('HTTP ' + svgResponse.status + ': ' + svgResponse.statusText);
                    }
                    const svgText = await svgResponse.text();
                    svgContainer.innerHTML = svgText;

                    // Get the SVG element
                    const svg = svgContainer.querySelector('svg');
                    if (svg) {
                        svg.removeAttribute('width');
                        svg.removeAttribute('height');
                        svg.style.width = '100%';
                        svg.style.height = 'auto';
                        svg.style.maxHeight = '800px';
                        svg.style.display = 'block';
                        svg.style.borderRadius = '8px';

                        // Override the CSS styles for regions to remove default coloring
                        const styleElement = svg.querySelector('style');
                        if (styleElement) {
                            styleElement.textContent += `
                                .region {
                                    fill-opacity: 1 !important;
                                }
                                .region:hover {
                                    fill-opacity: 1 !important;
                                }
                            `;
                        }

                        // Calculate color scale using Viridis
                        const minAge = Math.min(...yData.filter(v => v > 0));
                        const maxAge = Math.max(...yData);

                        // Viridis color scale function (simplified)
                        function getViridisColor(value, min, max) {
                            const t = Math.max(0, Math.min(1, (value - min) / (max - min)));
                            // Proper Viridis color scale (dark purple -> blue -> green -> yellow)
                            // Sample key points from the actual Viridis colormap
                            if (t < 0.25) {
                                const tt = t / 0.25;
                                const r = Math.floor(255 * (0.267004 + tt * (0.282623 - 0.267004)));
                                const g = Math.floor(255 * (0.004874 + tt * (0.140926 - 0.004874)));
                                const b = Math.floor(255 * (0.329415 + tt * (0.457517 - 0.329415)));
                                return `rgb(${r}, ${g}, ${b})`;
                            } else if (t < 0.5) {
                                const tt = (t - 0.25) / 0.25;
                                const r = Math.floor(255 * (0.282623 + tt * (0.163625 - 0.282623)));
                                const g = Math.floor(255 * (0.140926 + tt * (0.471133 - 0.140926)));
                                const b = Math.floor(255 * (0.457517 + tt * (0.558148 - 0.457517)));
                                return `rgb(${r}, ${g}, ${b})`;
                            } else if (t < 0.75) {
                                const tt = (t - 0.5) / 0.25;
                                const r = Math.floor(255 * (0.163625 + tt * (0.477504 - 0.163625)));
                                const g = Math.floor(255 * (0.471133 + tt * (0.687197 - 0.471133)));
                                const b = Math.floor(255 * (0.558148 + tt * (0.349303 - 0.558148)));
                                return `rgb(${r}, ${g}, ${b})`;
                            } else {
                                const tt = (t - 0.75) / 0.25;
                                const r = Math.floor(255 * (0.477504 + tt * (0.993248 - 0.477504)));
                                const g = Math.floor(255 * (0.687197 + tt * (0.906157 - 0.687197)));
                                const b = Math.floor(255 * (0.349303 + tt * (0.143936 - 0.349303)));
                                return `rgb(${r}, ${g}, ${b})`;
                            }
                        }

                        // Color each region
                        regions.forEach(region => {
                            const stats = regionStats[region.id];
                            const avgAge = stats.count > 0 ? stats.sum / stats.count : 0;

                            // The SVG uses "Region_01", "Region_02" format (underscore with zero-padding)
                            const paddedId = region.id.toString().padStart(2, '0');
                            const svgId = `Region_${paddedId}`;

                            const regionElement = svg.querySelector(`[id="${svgId}"]`);

                            if (regionElement) {
                                const color = stats.count > 0 ? getViridisColor(avgAge, minAge, maxAge) : '#000000';
                                regionElement.style.fill = color;
                                regionElement.style.fillOpacity = '1';
                                regionElement.style.stroke = '#ffffff';
                                regionElement.style.strokeWidth = '1';
                                regionElement.style.cursor = 'pointer';

                                // Add tooltip
                                const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                                title.textContent = `${region.name}: ${avgAge.toFixed(1)} Myr (${stats.count.toLocaleString()} stars)`;
                                regionElement.appendChild(title);

                                // Add click handler
                                regionElement.addEventListener('click', () => {
                                    alert(`${region.name}\\nAverage Age: ${avgAge.toFixed(1)} Myr\\nStars: ${stats.count.toLocaleString()}`);
                                });
                            } else {
                                console.warn('[Average Age by Region] Could not find SVG element for region', region.id, region.name);
                            }
                        });
                    } else {
                        console.error('[Average Age by Region] No SVG element found in loaded content');
                        svgContainer.innerHTML = '<div style="color: #888; padding: 20px;">SVG map loaded but no SVG element found</div>';
                    }
                } catch (svgError) {
                    console.error('[Average Age by Region] Error loading SVG:', svgError);
                    svgContainer.innerHTML = '<div style="color: #f44336; padding: 20px;">Could not load region map: ' + svgError.message + '</div>';
                }

                plotDiv.style.display = 'none';
                loadingDiv.innerHTML = '<div class="spinner"></div>Rendering chart...';
                await new Promise(resolve => requestAnimationFrame(resolve));

                await Plotly.newPlot(plotDiv, [trace], layout, {
                    responsive: true,
                    displayModeBar: true
                });

                plotDiv.style.display = 'block';
                Plotly.Plots.resize(plotDiv);

                loadingDiv.innerHTML = '<div style="color: #4a9eff; font-weight: 500;">✓ Loaded average ages for ' + regions.length + ' regions with ' + processedData.length.toLocaleString() + ' neutron stars</div>';
                loadedTabs.add(tabIndex);

            } catch (error) {
                console.error('[Average Age by Region] Error:', error);
                loadingDiv.innerHTML = '<div style="color: #f44336;">Error loading plot: ' + error.message + '</div>';
            }
        }

        async function loadHistograms(tabIndex) {
            const loadingDiv = document.getElementById('loading-' + tabIndex);
            loadingDiv.innerHTML = '<div class="spinner"></div>Waiting for complete dataset...';

            // Wait a moment for tab to fully render
            await new Promise(resolve => setTimeout(resolve, 100));

            try {
                // Get initial data
                const data = await loadCSVStreaming();
                if (!data) {
                    loadingDiv.innerHTML = '<div style="color: #f44336;">Error loading CSV</div>';
                    return;
                }

                // Wait for CSV to completely load
                while (!csvComplete) {
                    loadingDiv.innerHTML = '<div class="spinner"></div>Loading data... ' + csvData.length.toLocaleString() + ' rows loaded';
                    await new Promise(resolve => setTimeout(resolve, 200));
                }

                loadingDiv.innerHTML = '<div class="spinner"></div>Processing ' + csvData.length.toLocaleString() + ' data points...';

                // Process ALL data at once
                const processedData = await processWithWorker(csvData, null);

                console.log('[Histograms] Creating histograms with ' + processedData.length + ' total points');

                // Extract all values from complete dataset
                const radiusValues = processedData.map(r => r.solarRadius).filter(v => v !== null && v !== undefined);
                const periodValues = processedData.map(r => r.rotationalPeriod).filter(v => v !== null && v !== undefined);
                const ageValues = processedData.map(r => r.age).filter(v => v !== null && v !== undefined);
                const massValues = processedData.map(r => r.mass).filter(v => v !== null && v !== undefined);
                const tempValues = processedData.map(r => r.temperature).filter(v => v !== null && v !== undefined);
                const velocityValues = processedData.map(r => r.tangentialVelocity).filter(v => v !== null && v !== undefined);

                console.log('[Histograms] Value counts - radius: ' + radiusValues.length + ', period: ' + periodValues.length + ', age: ' + ageValues.length);

                const spinCounts = { up: 0, down: 0, none: 0 };
                processedData.forEach(r => {
                    if (r.spin === 'up') spinCounts.up++;
                    else if (r.spin === 'down') spinCounts.down++;
                    else if (r.spin === 'none') spinCounts.none++;
                });

                // Create histograms
                console.log('[Histograms] Creating radius histogram...');
                try {
                    await Plotly.newPlot('hist-radius', [{
                        x: radiusValues,
                        type: 'histogram',
                        nbinsx: 100,
                        marker: { color: '#4a9eff' },
                        name: 'Radius'
                    }], {
                        title: 'Radius Distribution',
                        xaxis: { title: 'Radius (km)', gridcolor: '#333' },
                        yaxis: { title: 'Count (log scale)', type: 'log', gridcolor: '#333' },
                        paper_bgcolor: '#1a1a1a',
                        plot_bgcolor: '#1a1a1a',
                        font: { color: '#fff' },
                        height: 380
                    }, { responsive: true });
                    console.log('[Histograms] Radius histogram created');
                } catch (e) {
                    console.error('[Histograms] Error creating radius histogram:', e);
                }

                try {
                    await Plotly.newPlot('hist-period', [{
                        x: periodValues,
                        type: 'histogram',
                        nbinsx: 100,
                        marker: { color: '#ff6b6b' },
                        name: 'Period'
                    }], {
                        title: 'Rotational Period Distribution',
                        xaxis: { title: 'Rotational Period (days)', gridcolor: '#333' },
                        yaxis: { title: 'Count (log scale)', type: 'log', gridcolor: '#333' },
                        paper_bgcolor: '#1a1a1a',
                        plot_bgcolor: '#1a1a1a',
                        font: { color: '#fff' },
                        height: 380
                    }, { responsive: true });
                    console.log('[Histograms] Period histogram created');
                } catch (e) {
                    console.error('[Histograms] Error creating period histogram:', e);
                }

                try {
                    await Plotly.newPlot('hist-age', [{
                        x: ageValues,
                        type: 'histogram',
                        nbinsx: 100,
                        marker: { color: '#51cf66' },
                        name: 'Age'
                    }], {
                        title: 'Age Distribution',
                        xaxis: { title: 'Age (Myr)', gridcolor: '#333' },
                        yaxis: { title: 'Count (log scale)', type: 'log', gridcolor: '#333' },
                        paper_bgcolor: '#1a1a1a',
                        plot_bgcolor: '#1a1a1a',
                        font: { color: '#fff' },
                        height: 380
                    }, { responsive: true });
                    console.log('[Histograms] Age histogram created');
                } catch (e) {
                    console.error('[Histograms] Error creating age histogram:', e);
                }

                try {
                    await Plotly.newPlot('hist-mass', [{
                        x: massValues,
                        type: 'histogram',
                        nbinsx: 100,
                        marker: { color: '#ffd43b' },
                        name: 'Mass'
                    }], {
                        title: 'Mass Distribution',
                        xaxis: { title: 'Mass (M☉)', gridcolor: '#333' },
                        yaxis: { title: 'Count (log scale)', type: 'log', gridcolor: '#333' },
                        shapes: [
                            {
                                type: 'line',
                                x0: 1.4,
                                x1: 1.4,
                                y0: 0,
                                y1: 1,
                                yref: 'paper',
                                line: { color: '#00ccff', width: 2, dash: 'dot' }
                            },
                            {
                                type: 'line',
                                x0: 2.5,
                                x1: 2.5,
                                y0: 0,
                                y1: 1,
                                yref: 'paper',
                                line: { color: '#9933ff', width: 2, dash: 'dot' }
                            }
                        ],
                        paper_bgcolor: '#1a1a1a',
                        plot_bgcolor: '#1a1a1a',
                        font: { color: '#fff' },
                        height: 380
                    }, { responsive: true });
                    console.log('[Histograms] Mass histogram created');
                } catch (e) {
                    console.error('[Histograms] Error creating mass histogram:', e);
                }

                try {
                    await Plotly.newPlot('hist-temperature', [{
                        x: tempValues,
                        type: 'histogram',
                        nbinsx: 100,
                        marker: { color: '#ff8787' },
                        name: 'Temperature'
                    }], {
                        title: 'Temperature Distribution',
                        xaxis: { title: 'Temperature (K)', gridcolor: '#333' },
                        yaxis: { title: 'Count (log scale)', type: 'log', gridcolor: '#333' },
                        paper_bgcolor: '#1a1a1a',
                        plot_bgcolor: '#1a1a1a',
                        font: { color: '#fff' },
                        height: 380
                    }, { responsive: true });
                    console.log('[Histograms] Temperature histogram created');
                } catch (e) {
                    console.error('[Histograms] Error creating temperature histogram:', e);
                }

                try {
                    await Plotly.newPlot('hist-velocity', [{
                        x: velocityValues,
                        type: 'histogram',
                        nbinsx: 100,
                        marker: { color: '#b197fc' },
                        name: 'Velocity'
                    }], {
                        title: 'Tangential Velocity Distribution',
                        xaxis: { title: 'Velocity (km/s)', gridcolor: '#333' },
                        yaxis: { title: 'Count (log scale)', type: 'log', gridcolor: '#333' },
                        shapes: [
                            {
                                type: 'line',
                                x0: 299792,
                                x1: 299792,
                                y0: 0,
                                y1: 1,
                                yref: 'paper',
                                line: { color: '#ff0000', width: 2, dash: 'dash' }
                            }
                        ],
                        paper_bgcolor: '#1a1a1a',
                        plot_bgcolor: '#1a1a1a',
                        font: { color: '#fff' },
                        height: 380
                    }, { responsive: true });
                    console.log('[Histograms] Velocity histogram created');
                } catch (e) {
                    console.error('[Histograms] Error creating velocity histogram:', e);
                }

                try {
                    await Plotly.newPlot('hist-spin', [{
                        x: ['Up', 'Down', 'None'],
                        y: [spinCounts.up, spinCounts.down, spinCounts.none],
                        type: 'bar',
                        marker: {
                            color: ['#00FF00', '#FF0000', '#FFA500']
                        },
                        name: 'Spin'
                    }], {
                        title: 'Spin State Distribution',
                        xaxis: { title: 'Spin State', gridcolor: '#333' },
                        yaxis: { title: 'Count', gridcolor: '#333' },
                        paper_bgcolor: '#1a1a1a',
                        plot_bgcolor: '#1a1a1a',
                        font: { color: '#fff' },
                        height: 380
                    }, { responsive: true });
                    console.log('[Histograms] Spin histogram created');
                } catch (e) {
                    console.error('[Histograms] Error creating spin histogram:', e);
                }

                console.log('[Histograms] All histograms created with ' + processedData.length + ' total points');
                loadingDiv.innerHTML = '<div style="color: #4a9eff; font-weight: 500;">✓ Loaded ' + csvData.length.toLocaleString() + ' data points</div>';
                loadedTabs.add(tabIndex);

            } catch (error) {
                console.error('[Histograms] Error:', error);
                loadingDiv.innerHTML = '<div style="color: #f44336;">Error loading histograms: ' + error.message + '</div>';
            }
        }

        async function loadAndStreamData(tabIndex) {
            const loadingDiv = document.getElementById('loading-' + tabIndex);
            const plotDiv = document.getElementById('plot-' + tabIndex);
            // Tab 12 is Mass-Radius by Age (special), so tab 13+ needs to map to plots array correctly
            const plotsIndex = tabIndex > 12 ? tabIndex - 1 : tabIndex;
            const plotConfig = plots[plotsIndex];
            const startTime = performance.now();

            console.log('[Plot ' + tabIndex + '] Starting load for: ' + plotConfig.title);

            if (!loadingDiv) {
                console.error('[Plot ' + tabIndex + '] Loading div not found: loading-' + tabIndex);
                return;
            }
            if (!plotDiv) {
                console.error('[Plot ' + tabIndex + '] Plot div not found: plot-' + tabIndex);
                return;
            }

            // Hide plot div and show loading in its place
            plotDiv.style.display = 'none';
            loadingDiv.innerHTML = '<div class="spinner"></div>Loading data: 0 rows...';
            loadingDiv.style.display = 'block';
            console.log('[Plot ' + tabIndex + '] Loading div shown');

            try {
                const progressCallback = (count, complete, regionName) => {
                    if (complete) {
                        loadingDiv.innerHTML = '<div class="spinner"></div>Loaded ' + count.toLocaleString() + ' rows, rendering chart...';
                    } else if (regionName) {
                        loadingDiv.innerHTML = '<div class="spinner"></div>Loading ' + regionName + ': ' + count.toLocaleString() + ' rows...';
                    } else {
                        loadingDiv.innerHTML = '<div class="spinner"></div>Loading data: ' + count.toLocaleString() + ' rows...';
                    }
                };

                const data = await loadCSVStreaming(progressCallback);
                if (!data) {
                    loadingDiv.innerHTML = '<div style="color: #f44336;">Error loading CSV</div>';
                    return;
                }

                const plotDiv = document.getElementById('plot-' + tabIndex);

                // Initialize worker if not exists
                if (!dataWorker) {
                    dataWorker = createDataWorker();
                }

                const xField = plotConfig.x;
                const yField = plotConfig.y;
                const colorField = plotConfig.color;

                // Track min/max x and y values for physics constraint lines
                let dataXMin = Infinity;
                let dataXMax = -Infinity;
                let dataYMin = Infinity;
                let dataYMax = -Infinity;

                // Process ALL data with worker
                console.log('[Plot ' + tabIndex + '] Processing ' + data.length.toLocaleString() + ' total rows from CSV');
                const processedData = await processWithWorker(data, null);
                console.log('[Plot ' + tabIndex + '] Worker returned ' + processedData.length.toLocaleString() + ' processed rows');

                // Filter out rows with null/undefined x or y values
                const validData = processedData.filter(r => {
                    const xVal = r[xField];
                    const yVal = r[yField];
                    return xVal !== null && xVal !== undefined && !isNaN(xVal) &&
                        yVal !== null && yVal !== undefined && !isNaN(yVal);
                });

                console.log('[Plot ' + tabIndex + '] Filtered to ' + validData.length.toLocaleString() + ' valid points for ' + xField + ' vs ' + yField);

                // If this is a large dataset, warn about performance and consider downsampling
                if (validData.length > 1000000) {
                    console.warn('[Plot ' + tabIndex + '] Large dataset: ' + validData.length.toLocaleString() + ' points - performance optimization active');
                    loadingDiv.innerHTML = '<div class="spinner"></div>Processing ' + validData.length.toLocaleString() + ' points (this may take a moment)...';
                }

                // Update min/max from valid data
                validData.forEach(r => {
                    const xVal = r[xField];
                    const yVal = r[yField];
                    if (xVal !== null && xVal !== undefined && !isNaN(xVal)) {
                        dataXMin = Math.min(dataXMin, xVal);
                        dataXMax = Math.max(dataXMax, xVal);
                    }
                    if (yVal !== null && yVal !== undefined && !isNaN(yVal)) {
                        dataYMin = Math.min(dataYMin, yVal);
                        dataYMax = Math.max(dataYMax, yVal);
                    }
                });

                // Apply smart downsampling for better performance
                let plotData;
                let allDataForZoom = null; // Store full dataset for dynamic zoom resampling

                // Downsample if dataset is very large (>2M points) or has compactness field
                if (validData.length > 2000000 || xField === 'compactness' || yField === 'compactness') {
                    console.log('[Plot ' + tabIndex + '] Applying smart downsampling (' + (xField === 'compactness' || yField === 'compactness' ? 'compactness plot' : 'large dataset') + ')');
                    // Use smaller grid for compactness (extreme clustering), larger for others
                    const gridSize = (xField === 'compactness' || yField === 'compactness') ? 600 : 1000;
                    plotData = downsampleForDisplay(validData, xField, yField, colorField, gridSize);
                    allDataForZoom = validData; // Keep full data for zoom interactions
                    console.log('[Plot ' + tabIndex + '] Downsampled from ' + validData.length.toLocaleString() + ' to ' + plotData.length.toLocaleString() + ' points');
                } else {
                    // Use all valid data without downsampling for smaller plots
                    plotData = validData;
                }

                // Calculate color range from ALL valid data for consistent colors
                // Process in chunks to avoid "too many arguments" error
                let colorMin = Infinity;
                let colorMax = -Infinity;
                for (let i = 0; i < plotData.length; i++) {
                    const val = plotData[i][colorField];
                    if (val !== null && val !== undefined && val > 0) {
                        if (val < colorMin) colorMin = val;
                        if (val > colorMax) colorMax = val;
                    }
                }

                // Pre-allocate arrays for performance
                const xData = new Array(plotData.length);
                const yData = new Array(plotData.length);
                const colorData = new Array(plotData.length);
                const systemData = new Array(plotData.length);
                const textData = new Array(plotData.length);

                for (let i = 0; i < plotData.length; i++) {
                    xData[i] = plotData[i][xField];
                    yData[i] = plotData[i][yField];
                    colorData[i] = plotData[i][colorField];
                    systemData[i] = plotData[i].system;
                    textData[i] = plotData[i].hoverText;
                }

                // Check if this plot needs separate spin state traces
                let traces = [];
                if (plotConfig.spinTraces) {
                    console.log('[Plot ' + tabIndex + '] Creating separate traces for spin states');

                    // Update loading message for spin trace processing
                    loadingDiv.innerHTML = '<div class="spinner"></div>Processing ' + plotData.length.toLocaleString() + ' points for spin traces...';

                    // Allow UI to update before heavy processing
                    await new Promise(resolve => setTimeout(resolve, 50));

                    const spinStates = [
                        { name: 'Spin Up', value: 'up', color: '#00ff00' },
                        { name: 'Spin Down', value: 'down', color: '#ff3333' },
                        { name: 'No Spin', value: 'none', color: '#ffaa00' }
                    ];

                    for (const spinState of spinStates) {
                        const spinData = plotData.filter(r => r.spin === spinState.value);
                        if (spinData.length === 0) continue;

                        const spinXData = spinData.map(r => r[xField]);
                        const spinYData = spinData.map(r => r[yField]);
                        const spinTextData = spinData.map(r => r.hoverText);
                        const spinSystemData = spinData.map(r => r.system);

                        traces.push({
                            x: spinXData,
                            y: spinYData,
                            mode: 'markers',
                            type: 'scattergl',
                            name: spinState.name + ' (' + spinData.length.toLocaleString() + ')',
                            marker: {
                                size: 4,
                                color: spinState.color,
                                opacity: 1.0
                            },
                            customdata: spinSystemData,
                            text: spinTextData,
                            hoverinfo: 'text',
                            legendgroup: spinState.value,
                            showlegend: true
                        });
                    }

                    // Update loading message before plotting
                    loadingDiv.innerHTML = '<div class="spinner"></div>Rendering chart with ' + traces.length + ' traces...';
                    await new Promise(resolve => setTimeout(resolve, 10));
                } else {
                    const trace = {
                        x: xData,
                        y: yData,
                        mode: 'markers',
                        type: 'scattergl',
                        marker: {
                            size: 3,
                            color: colorData,
                            colorscale: plotConfig.colorscale === 'viridis' ? 'Viridis' : 'Plasma',
                            showscale: true,
                            colorbar: { title: plotConfig.colorbar },
                            cmin: colorMin,
                            cmax: colorMax
                        },
                        customdata: systemData,
                        text: textData,
                        hoverinfo: 'text'
                    };
                    traces.push(trace);
                }

                // Determine axis types based on field names
                // Log scale for everything EXCEPT age, mass, radius (solarRadius), temperature, and compactness
                const xType = (plotConfig.x === 'age' || plotConfig.x === 'mass' || plotConfig.x === 'solarRadius' || plotConfig.x === 'temperature' || plotConfig.x === 'compactness') ? 'linear' : 'log';
                const yType = (plotConfig.y === 'age' || plotConfig.y === 'mass' || plotConfig.y === 'solarRadius' || plotConfig.y === 'temperature' || plotConfig.y === 'compactness') ? 'linear' : 'log';

                const layout = {
                    title: plotConfig.title,
                    xaxis: { title: plotConfig.xlabel, type: xType },
                    yaxis: { title: plotConfig.ylabel, type: yType },
                    paper_bgcolor: '#1a1a1a',
                    plot_bgcolor: '#1a1a1a',
                    font: { color: '#fff' },
                    hovermode: 'closest',
                    autosize: true,
                    height: 700,
                    margin: { l: 80, r: 80, t: 80, b: 80 },
                    showlegend: plotConfig.spinTraces ? true : false
                };

                // Add legend configuration for spin traces
                if (plotConfig.spinTraces) {
                    layout.legend = {
                        x: 1.02,
                        y: 1,
                        xanchor: 'left',
                        bgcolor: 'rgba(45, 45, 45, 0.9)',
                        bordercolor: '#555',
                        borderwidth: 1
                    };
                }

                // Add rotational period unit boundaries
                const periodBoundaries = [
                    { value: 1 / 86400000, label: '1 ms', color: '#555555' },
                    { value: 1 / 86400, label: '1 s', color: '#666666' },
                    { value: 1 / 1440, label: '1 min', color: '#777777' },
                    { value: 1 / 24, label: '1 hr', color: '#888888' },
                    { value: 1, label: '1 day', color: '#999999' },
                    { value: 7, label: '1 wk', color: '#aaaaaa' },
                    { value: 30, label: '1 mon', color: '#bbbbbb' },
                    { value: 365.25, label: '1 yr', color: '#cccccc' },
                    { value: 3652.5, label: '10 yr', color: '#dddddd' },
                    { value: 36525, label: '100 yr', color: '#eeeeee' }
                ];

                // Add period boundaries for plots with rotationalPeriod on Y axis (plots 0, 1, 7)
                if ([0, 1, 7].includes(tabIndex)) {
                    console.log('[Plot ' + tabIndex + '] Data Y range:', dataYMin, 'to', dataYMax);
                    layout.shapes = [];
                    // Only show boundaries within the data range
                    periodBoundaries.forEach(boundary => {
                        const inRange = boundary.value >= dataYMin && boundary.value <= dataYMax;
                        console.log('[Plot ' + tabIndex + '] Boundary', boundary.label, ':', boundary.value, 'in range?', inRange);
                        if (inRange) {
                            layout.shapes.push({
                                type: 'line',
                                x0: 0,
                                x1: 1,
                                xref: 'paper',
                                y0: boundary.value,
                                y1: boundary.value,
                                yref: 'y',
                                line: { color: boundary.color, width: 1, dash: 'dot' },
                                layer: 'below',
                                name: boundary.label
                            });
                        }
                    });
                }

                // Add period boundaries for plot with rotationalPeriod on X axis (plot 6: P-Pdot)
                if (tabIndex === 6) {
                    console.log('[Plot ' + tabIndex + '] Data X range:', dataXMin, 'to', dataXMax);
                    layout.shapes = [];
                    // Only show boundaries within the data range
                    periodBoundaries.forEach(boundary => {
                        const inRange = boundary.value >= dataXMin && boundary.value <= dataXMax;
                        console.log('[Plot ' + tabIndex + '] Boundary', boundary.label, ':', boundary.value, 'in range?', inRange);
                        if (inRange) {
                            layout.shapes.push({
                                type: 'line',
                                x0: boundary.value,
                                x1: boundary.value,
                                xref: 'x',
                                y0: 0,
                                y1: 1,
                                yref: 'paper',
                                line: { color: boundary.color, width: 1, dash: 'dot' },
                                layer: 'below'
                            });
                        }
                    });
                }

                // Add reference lines and annotations
                if (plotConfig.reference_line) {
                    if (!layout.shapes) layout.shapes = [];

                    // Check if tangential velocity is on x-axis (vertical line) or y-axis (horizontal line)
                    if (plotConfig.x === 'tangentialVelocity') {
                        // Vertical line for speed of light on x-axis
                        layout.shapes.push({
                            type: 'line',
                            x0: plotConfig.reference_line,
                            x1: plotConfig.reference_line,
                            xref: 'x',
                            y0: 0,
                            y1: 1,
                            yref: 'paper',
                            line: { color: '#00ff00', width: 2, dash: 'dash' }
                        });
                    } else {
                        // Horizontal line for speed of light on y-axis
                        layout.shapes.push({
                            type: 'line',
                            x0: 0,
                            x1: 1,
                            xref: 'paper',
                            y0: plotConfig.reference_line,
                            y1: plotConfig.reference_line,
                            yref: 'y',
                            line: { color: '#00ff00', width: 2, dash: 'dash' }
                        });
                    }
                }

                // Add physics constraint lines for Mass vs Radius plot (plot index 5)
                if (tabIndex === 5) {
                    // Schwarzschild radius: R = 2.95 km * M (solar masses)
                    // Now that radius is in km, the slope is just 2.95
                    const schwarzschildSlope = 2.95;

                    // Calculate Schwarzschild line endpoints constrained to data Y bounds
                    let schwY0 = dataXMin * schwarzschildSlope;
                    let schwY1 = dataXMax * schwarzschildSlope;
                    let schwX0 = dataXMin;
                    let schwX1 = dataXMax;

                    // Clip to Y bounds
                    if (schwY0 < dataYMin) {
                        schwX0 = dataYMin / schwarzschildSlope;
                        schwY0 = dataYMin;
                    }
                    if (schwY1 > dataYMax) {
                        schwX1 = dataYMax / schwarzschildSlope;
                        schwY1 = dataYMax;
                    }

                    layout.shapes = [
                        // Schwarzschild radius - dotted red diagonal
                        {
                            type: 'line',
                            x0: schwX0,
                            x1: schwX1,
                            y0: schwY0,
                            y1: schwY1,
                            line: { color: '#ff0000', width: 2.5, dash: 'dot' },
                            layer: 'below',
                            xref: 'x',
                            yref: 'y'
                        }
                    ];

                    // Only add TOV limit line if 2.5 is within data range
                    if (2.5 >= dataXMin && 2.5 <= dataXMax) {
                        layout.shapes.push({
                            type: 'line',
                            x0: 2.5,
                            x1: 2.5,
                            y0: dataYMin,
                            y1: dataYMax,
                            line: { color: '#9933ff', width: 2.5, dash: 'dot' },
                            layer: 'below',
                            xref: 'x',
                            yref: 'y'
                        });
                    }
                }

                // Add physics constraint lines for Rotational Period vs Mass plot (plot index 7)
                if (tabIndex === 7) {
                    layout.shapes = [];

                    // Add Chandrasekhar limit line if 1.4 is within data range
                    if (1.4 >= dataXMin && 1.4 <= dataXMax) {
                        layout.shapes.push({
                            type: 'line',
                            x0: 1.4,
                            x1: 1.4,
                            y0: dataYMin,
                            y1: dataYMax,
                            line: { color: '#00ccff', width: 2.5, dash: 'dot' },
                            layer: 'below',
                            xref: 'x',
                            yref: 'y'
                        });
                    }

                    // Add TOV limit line if 2.5 is within data range
                    if (2.5 >= dataXMin && 2.5 <= dataXMax) {
                        layout.shapes.push({
                            type: 'line',
                            x0: 2.5,
                            x1: 2.5,
                            y0: dataYMin,
                            y1: dataYMax,
                            line: { color: '#9933ff', width: 2.5, dash: 'dot' },
                            layer: 'below',
                            xref: 'x',
                            yref: 'y'
                        });
                    }
                }

                // Add physics constraint lines for Mass vs Age plot (plot index 8)
                if (tabIndex === 8) {
                    layout.shapes = [];

                    // Add Chandrasekhar limit line if 1.4 is within data range (horizontal line)
                    if (1.4 >= dataYMin && 1.4 <= dataYMax) {
                        layout.shapes.push({
                            type: 'line',
                            x0: dataXMin,
                            x1: dataXMax,
                            y0: 1.4,
                            y1: 1.4,
                            line: { color: '#00ccff', width: 2.5, dash: 'dot' },
                            layer: 'below',
                            xref: 'x',
                            yref: 'y'
                        });
                    }

                    // Add TOV limit line if 2.5 is within data range (horizontal line)
                    if (2.5 >= dataYMin && 2.5 <= dataYMax) {
                        layout.shapes.push({
                            type: 'line',
                            x0: dataXMin,
                            x1: dataXMax,
                            y0: 2.5,
                            y1: 2.5,
                            line: { color: '#9933ff', width: 2.5, dash: 'dot' },
                            layer: 'below',
                            xref: 'x',
                            yref: 'y'
                        });
                    }
                }

                // Add physics constraint lines for Tangential Velocity vs Mass plot (plot index 9)
                if (tabIndex === 9) {
                    layout.shapes = layout.shapes || [];
                    const SPEED_OF_LIGHT = 299792; // km/s

                    // Speed of light line is already added via reference_line property
                    // Add mass limit lines

                    // Add Chandrasekhar limit line if 1.4 is within data range (vertical line)
                    if (1.4 >= dataXMin && 1.4 <= dataXMax) {
                        layout.shapes.push({
                            type: 'line',
                            x0: 1.4,
                            x1: 1.4,
                            y0: dataYMin,
                            y1: dataYMax,
                            line: { color: '#00ccff', width: 2.5, dash: 'dot' },
                            layer: 'below',
                            xref: 'x',
                            yref: 'y'
                        });
                    }

                    // Add TOV limit line if 2.5 is within data range (vertical line)
                    if (2.5 >= dataXMin && 2.5 <= dataXMax) {
                        layout.shapes.push({
                            type: 'line',
                            x0: 2.5,
                            x1: 2.5,
                            y0: dataYMin,
                            y1: dataYMax,
                            line: { color: '#9933ff', width: 2.5, dash: 'dot' },
                            layer: 'below',
                            xref: 'x',
                            yref: 'y'
                        });
                    }
                }

                // Add physics constraint lines for P-Pdot diagram (plot index 6)
                if (tabIndex === 6) {
                    layout.shapes = [];
                    layout.annotations = [];

                    // Death line: log(Pdot) ≈ -15.5 + 0.5 * log(P)
                    // Convert to actual values: Pdot = 10^(-15.5) * P^0.5
                    // P is in days, need to convert to seconds for physics
                    const pRangeSeconds = [dataXMin * 86400, dataXMax * 86400];
                    const deathLinePoints = [];
                    for (let logP = Math.log10(pRangeSeconds[0]); logP <= Math.log10(pRangeSeconds[1]); logP += 0.1) {
                        const pSeconds = Math.pow(10, logP);
                        const pdot = Math.pow(10, -15.5 + 0.5 * logP);
                        deathLinePoints.push({ p: pSeconds / 86400, pdot: pdot });
                    }

                    // Add death line as a series of connected segments
                    for (let i = 0; i < deathLinePoints.length - 1; i++) {
                        layout.shapes.push({
                            type: 'line',
                            x0: deathLinePoints[i].p,
                            x1: deathLinePoints[i + 1].p,
                            y0: deathLinePoints[i].pdot,
                            y1: deathLinePoints[i + 1].pdot,
                            line: { color: '#ff0000', width: 2.5, dash: 'dash' },
                            layer: 'below'
                        });
                    }

                    // Add age contour lines: Pdot = P / (2 * age)
                    // Age in seconds, P in seconds, Pdot is dimensionless (s/s)
                    const ageContours = [
                        { years: 1e3, label: '1 kyr', color: '#888888' },
                        { years: 1e6, label: '1 Myr', color: '#888888' },
                        { years: 1e9, label: '1 Gyr', color: '#888888' }
                    ];

                    ageContours.forEach(({ years, label, color }) => {
                        const ageSeconds = years * 365.25 * 86400;
                        const ageLinePoints = [];

                        for (let logP = Math.log10(pRangeSeconds[0]); logP <= Math.log10(pRangeSeconds[1]); logP += 0.1) {
                            const pSeconds = Math.pow(10, logP);
                            const pdot = pSeconds / (2 * ageSeconds);
                            ageLinePoints.push({ p: pSeconds / 86400, pdot: pdot });
                        }

                        // Add age line as connected segments
                        for (let i = 0; i < ageLinePoints.length - 1; i++) {
                            layout.shapes.push({
                                type: 'line',
                                x0: ageLinePoints[i].p,
                                x1: ageLinePoints[i + 1].p,
                                y0: ageLinePoints[i].pdot,
                                y1: ageLinePoints[i + 1].pdot,
                                line: { color: color, width: 1.5, dash: 'dot' },
                                layer: 'below'
                            });
                        }

                        // Add label annotation at the right end
                        const lastPoint = ageLinePoints[ageLinePoints.length - 1];
                        layout.annotations.push({
                            x: Math.log10(lastPoint.p),
                            y: Math.log10(lastPoint.pdot),
                            text: label,
                            showarrow: false,
                            font: { color: color, size: 11 },
                            xanchor: 'left',
                            xshift: 5
                        });
                    });
                }

                // Prepare boundary hover traces
                const boundaryTraces = [];

                // Add hover traces for period boundaries on Y axis
                if ([0, 1, 7].includes(tabIndex)) {
                    periodBoundaries.forEach(boundary => {
                        if (boundary.value >= dataYMin && boundary.value <= dataYMax) {
                            boundaryTraces.push({
                                x: [dataXMin, dataXMax],
                                y: [boundary.value, boundary.value],
                                mode: 'lines',
                                line: { width: 0 },
                                hoverinfo: 'text',
                                text: boundary.label,
                                showlegend: false
                            });
                        }
                    });
                }

                // Add hover traces for period boundaries on X axis
                if (tabIndex === 6) {
                    periodBoundaries.forEach(boundary => {
                        if (boundary.value >= dataXMin && boundary.value <= dataXMax) {
                            boundaryTraces.push({
                                x: [boundary.value, boundary.value],
                                y: [dataYMin, dataYMax],
                                mode: 'lines',
                                line: { width: 0 },
                                hoverinfo: 'text',
                                text: boundary.label,
                                showlegend: false
                            });
                        }
                    });
                }

                // Add legend key for physics constraint lines
                if (tabIndex === 5) {
                    layout.annotations = layout.annotations || [];
                    let yPos = 0.98;

                    layout.annotations.push({
                        x: 0.98,
                        y: yPos,
                        xref: 'paper',
                        yref: 'paper',
                        text: '⋯⋯⋯ Schwarzschild Radius',
                        showarrow: false,
                        font: { color: '#ff0000', size: 12 },
                        xanchor: 'right',
                        yanchor: 'top',
                        bgcolor: 'rgba(0,0,0,0.7)',
                        borderpad: 4
                    });

                    if (2.5 >= dataXMin && 2.5 <= dataXMax) {
                        yPos -= 0.06;
                        layout.annotations.push({
                            x: 0.98,
                            y: yPos,
                            xref: 'paper',
                            yref: 'paper',
                            text: '⋯⋯⋯ TOV Limit (2.5 M☉)',
                            showarrow: false,
                            font: { color: '#9933ff', size: 12 },
                            xanchor: 'right',
                            yanchor: 'top',
                            bgcolor: 'rgba(0,0,0,0.7)',
                            borderpad: 4
                        });
                    }
                }

                // Update loading message for rendering phase
                loadingDiv.innerHTML = '<div class="spinner"></div>Rendering ' + plotData.length.toLocaleString() + ' points on chart...';

                // Use requestAnimationFrame to allow UI update before blocking render
                await new Promise(resolve => requestAnimationFrame(resolve));

                const renderStart = performance.now();
                Plotly.newPlot(plotDiv, [...traces, ...boundaryTraces], layout, {
                    responsive: true,
                    displayModeBar: true
                });
                const renderTime = ((performance.now() - renderStart) / 1000).toFixed(1);
                console.log('[Plot ' + tabIndex + '] Plotly render took ' + renderTime + 's');

                // Show plot div and resize to fit
                plotDiv.style.display = 'block';
                Plotly.Plots.resize(plotDiv);

                // Add zoom handler for dynamic resampling on compactness plot
                // Skip zoom handler for spin traces plots as they already have all data loaded
                if (allDataForZoom && !plotConfig.spinTraces) {
                    let zoomTimeout = null;
                    let loadingOverlay = null;

                    // Store original data for reset functionality
                    const originalData = {
                        x: [...xData],
                        y: [...yData],
                        color: [...colorData],
                        text: [...textData],
                        customdata: [...systemData]
                    };

                    plotDiv.on('plotly_relayout', function (eventData) {
                        console.log('[Plot ' + tabIndex + '] Relayout event:', eventData);

                        // Check if this is a reset/autoscale event
                        if (eventData['xaxis.autorange'] || eventData['yaxis.autorange']) {
                            console.log('[Plot ' + tabIndex + '] Reset axes detected, restoring original data...');

                            // Clear any pending zoom operation
                            if (zoomTimeout) {
                                clearTimeout(zoomTimeout);
                            }

                            // Restore original downsampled data
                            Plotly.restyle(plotDiv, {
                                x: [originalData.x],
                                y: [originalData.y],
                                'marker.color': [originalData.color],
                                text: [originalData.text],
                                customdata: [originalData.customdata]
                            }, 0);

                            console.log('[Plot ' + tabIndex + '] Original data restored (' + originalData.x.length.toLocaleString() + ' points)');
                            return;
                        }

                        // Check if this is a zoom event (has xaxis.range or yaxis.range)
                        if (!eventData['xaxis.range[0]'] && !eventData['xaxis.range']) return;

                        // Clear any pending zoom operation
                        if (zoomTimeout) {
                            clearTimeout(zoomTimeout);
                        }

                        // Show loading overlay
                        if (!loadingOverlay) {
                            loadingOverlay = document.createElement('div');
                            loadingOverlay.className = 'loading-overlay';
                            loadingOverlay.innerHTML = '<div class="spinner"></div><div class="message">Please wait, loading more data...</div>';
                            plotDiv.parentElement.style.position = 'relative';
                            plotDiv.parentElement.appendChild(loadingOverlay);
                        }
                        loadingOverlay.style.display = 'flex';

                        // Debounce zoom handling to avoid excessive computation
                        zoomTimeout = setTimeout(async function () {
                            console.log('[Plot ' + tabIndex + '] Zoom detected, resampling data for current view...');

                            // Get current axis ranges - handle both possible formats
                            let xRange, yRange;
                            if (eventData['xaxis.range[0]'] !== undefined) {
                                xRange = [eventData['xaxis.range[0]'], eventData['xaxis.range[1]']];
                            } else if (eventData['xaxis.range']) {
                                xRange = eventData['xaxis.range'];
                            }

                            if (eventData['yaxis.range[0]'] !== undefined) {
                                yRange = [eventData['yaxis.range[0]'], eventData['yaxis.range[1]']];
                            } else if (eventData['yaxis.range']) {
                                yRange = eventData['yaxis.range'];
                            }

                            if (!xRange || !yRange) {
                                console.log('[Plot ' + tabIndex + '] Missing axis ranges, skipping resample');
                                loadingOverlay.style.display = 'none';
                                return;
                            }

                            console.log('[Plot ' + tabIndex + '] X range:', xRange, 'Y range:', yRange);

                            // Handle log scale axes - Plotly returns ranges in log space for log axes
                            // Need to convert back to linear space for data filtering
                            const useLogX = xType === 'log';
                            const useLogY = yType === 'log';

                            const xMin = useLogX ? Math.pow(10, xRange[0]) : xRange[0];
                            const xMax = useLogX ? Math.pow(10, xRange[1]) : xRange[1];
                            const yMin = useLogY ? Math.pow(10, yRange[0]) : yRange[0];
                            const yMax = useLogY ? Math.pow(10, yRange[1]) : yRange[1];

                            console.log('[Plot ' + tabIndex + '] Linear ranges - X:', xMin, 'to', xMax, ', Y:', yMin, 'to', yMax);

                            // Filter data to visible range
                            const visibleData = allDataForZoom.filter(r => {
                                const xVal = r[xField];
                                const yVal = r[yField];
                                return xVal >= xMin && xVal <= xMax &&
                                    yVal >= yMin && yVal <= yMax;
                            });

                            console.log('[Plot ' + tabIndex + '] Visible data: ' + visibleData.length.toLocaleString() + ' points in view');

                            // Resample visible data with finer grid when zoomed in
                            const resampledData = downsampleForDisplay(visibleData, xField, yField, colorField, 1000);
                            console.log('[Plot ' + tabIndex + '] Resampled to ' + resampledData.length.toLocaleString() + ' points for zoomed view');

                            // Build new data arrays
                            const newXData = resampledData.map(r => r[xField]);
                            const newYData = resampledData.map(r => r[yField]);
                            const newColorData = resampledData.map(r => r[colorField]);
                            const newTextData = resampledData.map(r => r.hoverText);
                            const newSystemData = resampledData.map(r => r.system);

                            // Update the plot with new data - include customdata for click handler
                            await Plotly.restyle(plotDiv, {
                                x: [newXData],
                                y: [newYData],
                                'marker.color': [newColorData],
                                text: [newTextData],
                                customdata: [newSystemData]
                            }, 0);

                            // Hide loading overlay
                            loadingOverlay.style.display = 'none';
                        }, 500); // Wait 500ms after last zoom event before processing
                    });
                }

                if (tabIndex === 6) {
                    layout.annotations = layout.annotations || [];
                    layout.annotations.push({
                        x: 0.02,
                        y: -0.15,
                        xref: 'paper',
                        yref: 'paper',
                        text: '--- Death Line',
                        showarrow: false,
                        font: { color: '#ff0000', size: 12 },
                        xanchor: 'left',
                        yanchor: 'top',
                        bgcolor: 'rgba(0,0,0,0.5)',
                        borderpad: 4
                    });
                    layout.annotations.push({
                        x: 0.22,
                        y: -0.15,
                        xref: 'paper',
                        yref: 'paper',
                        text: '⋯⋯⋯ Constant Age Lines',
                        showarrow: false,
                        font: { color: '#888888', size: 12 },
                        xanchor: 'left',
                        yanchor: 'top',
                        bgcolor: 'rgba(0,0,0,0.5)',
                        borderpad: 4
                    });
                }

                if (tabIndex === 7) {
                    layout.annotations = layout.annotations || [];
                    let xPos = 0.02;

                    if (1.4 >= dataXMin && 1.4 <= dataXMax) {
                        layout.annotations.push({
                            x: xPos,
                            y: -0.15,
                            xref: 'paper',
                            yref: 'paper',
                            text: '⋯⋯⋯ Chandrasekhar Limit (1.4 M☉)',
                            showarrow: false,
                            font: { color: '#00ccff', size: 12 },
                            xanchor: 'left',
                            yanchor: 'top',
                            bgcolor: 'rgba(0,0,0,0.5)',
                            borderpad: 4
                        });
                        xPos += 0.35;
                    }

                    if (2.5 >= dataXMin && 2.5 <= dataXMax) {
                        layout.annotations.push({
                            x: xPos,
                            y: -0.15,
                            xref: 'paper',
                            yref: 'paper',
                            text: '⋯⋯⋯ TOV Limit (2.5 M☉)',
                            showarrow: false,
                            font: { color: '#9933ff', size: 12 },
                            xanchor: 'left',
                            yanchor: 'top',
                            bgcolor: 'rgba(0,0,0,0.5)',
                            borderpad: 4
                        });
                    }
                }

                if (tabIndex === 8) {
                    layout.annotations = layout.annotations || [];
                    let xPos = 0.02;

                    if (1.4 >= dataYMin && 1.4 <= dataYMax) {
                        layout.annotations.push({
                            x: xPos,
                            y: -0.15,
                            xref: 'paper',
                            yref: 'paper',
                            text: '⋯⋯⋯ Chandrasekhar Limit (1.4 M☉)',
                            showarrow: false,
                            font: { color: '#00ccff', size: 12 },
                            xanchor: 'left',
                            yanchor: 'top',
                            bgcolor: 'rgba(0,0,0,0.5)',
                            borderpad: 4
                        });
                        xPos += 0.35;
                    }

                    if (2.5 >= dataYMin && 2.5 <= dataYMax) {
                        layout.annotations.push({
                            x: xPos,
                            y: -0.15,
                            xref: 'paper',
                            yref: 'paper',
                            text: '⋯⋯⋯ TOV Limit (2.5 M☉)',
                            showarrow: false,
                            font: { color: '#9933ff', size: 12 },
                            xanchor: 'left',
                            yanchor: 'top',
                            bgcolor: 'rgba(0,0,0,0.5)',
                            borderpad: 4
                        });
                    }
                }

                if (tabIndex === 9) {
                    layout.annotations = layout.annotations || [];
                    layout.annotations.push({
                        x: 0.5,
                        y: -0.15,
                        xref: 'paper',
                        yref: 'paper',
                        text: 'Chandrasekhar limit (1.4 M☉) | TOV limit (2.5 M☉) | Speed of light (c)',
                        showarrow: false,
                        font: { color: '#aaa', size: 11 },
                        xanchor: 'center',
                        yanchor: 'top'
                    });
                }

                // Add click handler for navigation to Canonn signals
                plotDiv.on('plotly_click', function (data) {
                    const point = data.points[0];
                    if (point && point.customdata) {
                        const systemName = point.customdata;
                        const url = 'https://signals.canonn.tech/?system=' + encodeURIComponent(systemName);
                        console.log('[Plot] Opening system:', systemName, 'at', url);
                        window.open(url, '_blank');
                    }
                });

                // All data is loaded, show final status
                const totalTime = ((performance.now() - startTime) / 1000).toFixed(1);
                loadingDiv.innerHTML = '<div style="color: #4a9eff; font-weight: 500;">✓ Loaded ' + plotData.length.toLocaleString() + ' points in ' + totalTime + 's (render: ' + renderTime + 's) | Click any point to view in Canonn Signals</div>';
                loadedTabs.add(tabIndex);

            } catch (error) {
                console.error('[Plot ' + tabIndex + '] Error:', error);
                loadingDiv.innerHTML = '<div style="color: #f44336;">Error loading plot: ' + error.message + '</div>';
                plotDiv.style.display = 'block';
            }
        }

        window.addEventListener('DOMContentLoaded', () => {
            loadAndStreamData(0);
        });

        // Handle window resize to prevent plots from vanishing
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                for (let i = 0; i < plots.length; i++) {
                    const plotDiv = document.getElementById('plot-' + i);
                    if (plotDiv && plotDiv.data && plotDiv.layout) {
                        const container = plotDiv.parentElement;
                        const width = container.offsetWidth;
                        Plotly.relayout(plotDiv, {
                            width: width,
                            height: 700
                        });
                    }
                }
            }, 100);
        });
    </script>
</body>

</html>